-- A flag to ensure the teleport happens only once
_G.Teleported = _G.Teleported or false

if not _G.Teleported then
    _G.Teleported = true -- Mark teleport as done

    if game.Players.LocalPlayer.Character then
        -- Teleport immediately if the character is already loaded
        game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart").CFrame = CFrame.new(-543, 173, -4)
    else
        -- Teleport when the character spawns, only if it hasn't already happened
        game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
            char:WaitForChild("HumanoidRootPart").CFrame = CFrame.new(-543, 173, -4)
        end)
    end
end

loadstring(game:HttpGet("https://raw.githubusercontent.com/bebepro/anticheat/refs/heads/main/bypass"))()


game:GetService("StarterGui"):SetCore("SendNotification",{
Title = "InDay loading..",
Text = "made by @2fj0 & Gamerhacker", 

Duration = 2 
})



RunService = game:GetService("RunService")
player = game.Players.LocalPlayer

-- // Tables
local Library, Utility, Flags, Theme = loadstring(game:HttpGet("https://raw.githubusercontent.com/bebepro/resuu.ui/refs/heads/main/resuu.ui"))();
--
local Themes, Visualisation, Visuals, Desync, Movement, Camera, Color, Math, Tween, Chat, Languages, Atlanta = {
    Default = {1, [[{"Outline":"000000","Accent":"FFFFCC","LightText":"ffffff","DarkText":"afafaf","LightContrast":"1e1e1e","CursorOutline":"FFFFFF","DarkContrast":"141414","TextBorder":"000000","Inline":"323232"}]]},
    Abyss = {2, [[{"Outline":"0a0a0a","Accent":"8c87b4","LightText":"ffffff","DarkText":"afafaf","LightContrast":"1e1e1e","CursorOutline":"141414","DarkContrast":"141414","TextBorder":"0a0a0a","Inline":"2d2d2d"}]]},
    Fatality = {3, [[{"Outline":"0f0f28","Accent":"f00f50","LightText":"c8c8ff","DarkText":"afafaf","LightContrast":"231946","CursorOutline":"0f0f28","DarkContrast":"191432","TextBorder":"0a0a0a","Inline":"322850"}]]},
    Neverlose = {4, [[{"Outline":"000005","Accent":"00b4f0","LightText":"ffffff","DarkText":"afafaf","LightContrast":"000f1e","CursorOutline":"0f0f28","DarkContrast":"050514","TextBorder":"0a0a0a","Inline":"0a1e28"}]]},
    Aimware = {5, [[{"Outline":"000005","Accent":"c82828","LightText":"e8e8e8","DarkText":"afafaf","LightContrast":"2b2b2b","CursorOutline":"191919","DarkContrast":"191919","TextBorder":"0a0a0a","Inline":"373737"}]]},
    Youtube = {6, [[{"Outline":"000000","Accent":"ff0000","LightText":"f1f1f1","DarkText":"aaaaaa","LightContrast":"232323","CursorOutline":"121212","DarkContrast":"0f0f0f","TextBorder":"121212","Inline":"393939"}]]},
    Gamesense = {7, [[{"Outline":"000000","Accent":"a7d94d","LightText":"ffffff","DarkText":"afafaf","LightContrast":"171717","CursorOutline":"141414","DarkContrast":"0c0c0c","TextBorder":"141414","Inline":"282828"}]]},
    Onetap = {8, [[{"Outline":"000000","Accent":"dda85d","LightText":"d6d9e0","DarkText":"afafaf","LightContrast":"2c3037","CursorOutline":"000000","DarkContrast":"1f2125","TextBorder":"000000","Inline":"4e5158"}]]},
    Entropy = {9, [[{"Outline":"0a0a0a","Accent":"81bbe9","LightText":"dcdcdc","DarkText":"afafaf","LightContrast":"3d3a43","CursorOutline":"000000","DarkContrast":"302f37","TextBorder":"000000","Inline":"4c4a52"}]]},
    Interwebz = {10, [[{"Outline":"1a1a1a","Accent":"c9654b","LightText":"fcfcfc","DarkText":"a8a8a8","LightContrast":"291f38","CursorOutline":"1a1a1a","DarkContrast":"1f162b","TextBorder":"000000","Inline":"40364f"}]]},
    Dracula = {11, [[{"Outline":"202126","Accent":"9a81b3","LightText":"b4b4b8","DarkText":"88888b","LightContrast":"2a2c38","CursorOutline":"202126","DarkContrast":"252730","TextBorder":"2a2c38","Inline":"3c384d"}]]},
    Spotify = {12, [[{"Outline":"0a0a0a","Accent":"1ed760","LightText":"d0d0d0","DarkText":"949494","LightContrast":"181818","CursorOutline":"000000","DarkContrast":"121212","TextBorder":"000000","Inline":"292929"}]]},
    Sublime = {13, [[{"Outline":"000000","Accent":"ff9800","LightText":"e8ffff","DarkText":"d3d3c2","LightContrast":"32332d","CursorOutline":"000000","DarkContrast":"282923","TextBorder":"000000","Inline":"484944"}]]},
    Vape = {14, [[{"Outline":"0a0a0a","Accent":"26866a","LightText":"dcdcdc","DarkText":"afafaf","LightContrast":"1f1f1f","CursorOutline":"000000","DarkContrast":"1a1a1a","TextBorder":"000000","Inline":"363636"}]]},
    Neko = {15, [[{"Outline":"000000","Accent":"d21f6a","LightText":"ffffff","DarkText":"afafaf","LightContrast":"171717","CursorOutline":"0a0a0a","DarkContrast":"131313","TextBorder":"000000","Inline":"2d2d2d"}]]},
    Corn = {16, [[{"Outline":"000000","Accent":"ff9000","LightText":"dcdcdc","DarkText":"afafaf","LightContrast":"252525","CursorOutline":"000000","DarkContrast":"191919","TextBorder":"000000","Inline":"333333"}]]},
    Minecraft = {17, [[{"Outline":"000000","Accent":"27ce40","LightText":"ffffff","DarkText":"d7d7d7","LightContrast":"333333","CursorOutline":"000000","DarkContrast":"262626","TextBorder":"000000","Inline":"333333"}]]},
}, {
    Character = nil,
    Texture = 5,
    LastUpdate = {}
}, {
    Bases = {},
    Base = {}
}, {
    Enabled = false,
    SmoothValue = 0,
    Rotate = Vector3.new(720, 360, 720),
    Rotate2 = Vector3.new(),
    Real = {
        CFrame = nil,
        Velocity = nil,
        RotVelocity = nil
    },
    Fake = {
        CFrame = CFrame.new(),
        Velocity = Vector3.new(),
        RotVelocity = Vector3.new()
    },
    Sent = CFrame.new()
}, {
    Velocity = 0,
    State = {},
    LastPosition = CFrame.new()
}, {
}, {
}, {
    Conversions = {}
}, {
}, {
    LastTick = tick()
}, {
    ["Lt"] = {
        ["[%s]  -  [Account = $ACC [$UID],  Build = $BUILD,  Ping = $PING,  FPS = $FPS]"] = "[%s]  -  [Akountas = $ACC [$UID],  Versija = $BUILD,  Ping = $PING,  FPS = $FPS]",
        ["Rage"] = "Akivaizdus",
        ["Players"] = "Zaidejiai",
        ["Visuals"] = "Vaizdai",
        ["Misc"] = "Ivairus",
        ["Settings"] = "Parametrai",
        ["Configs"] = "Konfigur..",

        
        ["Aim Assist"] = "Taikymo Pagalba",
        ["Trigger Bot"] = "Saidymo Botas",

        ["Enabled"] = "Ijungtas",
        ["Field Of View"] = "Matymo Ratas",
        ["Horizontal Smoothing"] = "Horizontalus Lygumas",
        ["Vertical Smoothing"] = "Vertikalus Lygumas",
        ["Dynamic Smoothing"] = "Dinaminis Lygumas",
        ["Aim Assist Checks"] = "Taikymo Pagalbos Patikrinimai",
        ["Hit Boxes"] = "Patikymo Dalis",
        ["Randomise Hitbox Position"] = "Atsitiktinis Patikymo Dalis Pos.",
        ["Hitscan Type"] = "Hit Skano Tipas",
        ["Wall Check Origin"] = "Sienu Patikrinimas",
        ["Readjustment"] = "Koregavimas",
        ["Deadzone"] = "Ne Taikymo Zona",
        ["Stutter"] = "Mikcioti",
        ["Humaniser"] = "Humanizatorius",
        ["Humaniser Scale"] = "Humanizatoriu Skale",

        ["Delay"] = "Sutrukdyti",
        ["Interval"] = "Intervalas",
        ["Trigger Bot Checks"] = "Saidymo Boto Patikrinimai",

        ["Cursor Offset"] = "Peles Poslinkis",


        ["Enemies"] = "Priesai",
        ["Friendlies"] = "Draugai",
        ["Local"] = "Vietinis",
        ["Colors"] = "Spalvos",
        ["Extra"] = "Papildomai",

        ["Name"] = "Vardas",
        ["Bounding Box"] = "Erdvine Dezute",
        ["Health Bar"] = "Sveikatos Dezute",
        ["Health Number"] = "Sveikatos Numeris",
        ["Offscreen Arrows"] = "Rodykles",
        ["Arrow Size"] = "Rodykles Dydis",
        ["Arrow Position"] = "Rodykles Posicija",
        ["Arrow Types"] = "Rodykliu Tipai",
        ["Arrow Distance"] = "Rodykliu Atstumas",
        ["Tool"] = "Irankis",
        ["Distance"] = "Atstumas",
        ["Flags"] = "Tipai",
        ["Flag Types"] = "Tipu Veliaveles",
        ["Chams"] = "Kuno Uzpildymas",
        ["Automatic Color"] = "Automatine Spalva",
        ["Max Distance"] = "Maksimalus Atstumas",

        ["Visualisation"] = "Vizualizacija",
        ["Visualise Server Position"] = "Vizualizuoti Serverio Posicija",
        ["Visualisation Material"] = "Vizualizacijos Medziaga",

        ["Highlight Friendlies"] = "Paryskinti Draugus",
        ["Highlight Priorities"] = "Paryskinti Prioritetus",
        ["Highlight Targets"] = "Paryskinti Tikslus",

        ["Use Display Name"] = "Naudoti Pavadinima",
        ["Name Length"] = "Vardo Ilgis",
        ["Text Surround"] = "Teksto Apsuptis",
        ["ESP Fade Out"] = "ESP Isnyks Laikas",
        ["Distance Measurement"] = "Atstumo Matavimas",


        ["Lighting"] = "Atmosfera",
        ["Camera"] = "Kamera",

        ["Ambient"] = "Atmosfera",
        ["Brightness"] = "Ryskuma",
        ["Clock Time"] = "Laikas",
        ["Color Shift"] = "Spalvu Poslinkis",
        ["Exposure"] = "Poveikis",
        ["Fog"] = "Rukas",
        ["Fog End"] = "Ruko Galas",
        ["Fog Start"] = "Ruko Pradis",
        
        ["Velocity Graph"] = "Greicio Grafikas",
        ["Third Person"] = "Kameros Atstumas",
        ["Freecam"] = "Pilna Kamera",
        ["Zoom"] = "Priartinimas",
        
        ["Field Of View "] = "Kameros Priartinimas",
        
        ["Aim Assist FOV Circle"] = "Taikymo Pagalbos Ratas",
        ["Deadzone FOV Circle"] = "Ne Taikymos Zonos Ratas",
        
        ["Cursor"] = "Pelite",
        ["Dot"] = "Taskas",
        ["Size"] = "Dydis",
        ["Dynamic Size"] = "Dynamiskas Dydzis",
        ["Gap"] = "Tarpas",
        ["Spinning"] = "Sukasi",
        ["Follow Mouse"] = "Sekti Pelite",
        ["Thickness"] = "Storis",
        ["Easing Style"] = "Svelninimo Stilius",


        ["Main"] = "Pagrindinis",
        ["Custom"] = "Pasirinktinis",
        ["Chat"] = "Pokalbiu",
        ["Movement"] = "Judejimas",

        ["Client Desync"] = "Desinchronizavimas",
        ["Speed"] = "Greitis",
        ["Position Method"] = "Posicijios Metodas",
        ["Turn Method"] = "Pasukimo Metodas",
        ["Turn Smoothing"] = "Pasukimo Lygimas",
        ["Easing Direction"] = "Svelninimo Kryptis",
        ["Velocity Method"] = "Velocijos Metodas",
        ["Velocity Multiplier"] = "Velocjos Daugiklis",

        ["Chat Spam"] = "Pokalbio Slamstas",
        ["Chat Spam Type"] = "Pokalbio Slamsto Tipas",
        ["Song Name"] = "Dainos Pavadinimas",
        ["Multiple"] = "Kelis",
        ["Emojis"] = "Jaustukai",
        ["Symbols"] = "Symbolai",

        ["Disable Networking"] = "Isjungti Tinkla",
        ["Fake Lag"] = "Netikras Atsilikimas",
        ["Fake Lag Ammount"] = "Atsilikimo Suma",
        ["Fake Lag Multiplier"] = "Atsilikimo Daugiklis",
        ["Return Desync"] = "Grazinti Desinchro..",
        ["Return Type"] = "Grazinimo Tipas",
        ["Lag Switch"] = "Strigimo Jungiklis",

    },
    ["Eng"] = {}
}, {
    Configs = {},
    Drawings = {},
    Locals = {
        SelectedPage = "Config",
        SelectedPlayersSection = "Enemies",
        LastTick = tick(),
        ShiftTick = tick(),
        LastStutter = tick(),
        TriggerTick = tick(),
        Shift = 0,
        CursorAngle = 0,
        CursorSize = 0,
        DeadzoneFOV = 90,
        Humaniser = {
            Tick = tick(),
            Sample = nil,
            Index = 1
        },
        Sample = Sample,
        SongQueue = 1,
        LastPreviewUpdate = tick(),
        BadWords = {"bitch", "fuck", "nigga", "nigger", "fucking", "retard", "dumbass", "stupid", "whore", "idiot", "weed", "crack", "faggot", "gay", "lean", "love", "kiss", "abuse", "clang", "shit", "high", "kill", "child", "hoe", " ho ", "perc", "pill"},
        Strings = {
            Atlanta = {"Atlanta", "Space", "OMG", "Lost 2 ATLANTA", "gamesneeze.cc", "omg so bad", "imagine dying to me", "WOW!", "WOWZIES", "OH MY DAYS", "atlanta'd", "1d luh bro", "WOW U SUCK", "sooooo bad", "couldnt be me", "just broke ur ankles", "UR ANKLES? GONE?", "destroyed", "LOL DESTROYED", "LOL"},
            Troll = {"Cheating? Whats that?", "My aim is so good", "Uhh guys..?", "How do I play the game?", "How do I shoot", "Whoops misclicked", "You mad bro?", "My dog is playing for me", "GET GUD", "How do i kill somebody", "Whoopsies didnt mean to shoot ğŸ™Š", "Sorry brah", "What the hell", "Guys who is that cheater", "Wow HACKER", "HACKER IN THE GAME GUYS"},
            Toxic = {"lol so bad", "Yall doo doo", "Cant hit me?", "Try harder", "omg you are terrible", "terrible", "DESTROYED", "POW", "oh my god", "you suck brah", "bruh..", "TROLL", "troll", "wth? ur bad?", "not cheating just good", "2 GOOD 4 U", "soooo good", "omg so easy", "SO EASY", "bro this is too easy LOL", "LOL", "wow you guys are really terrible", "about to fall asleep", "ASLEEP ğŸ›ğŸ’¤ğŸ˜ªğŸ˜´", "snoozing.. ğŸ’¤ğŸ’¤", "bruh yall suck ğŸ—£ğŸ—£", "so bad lol", "better than u", "OMG SO BAD WTH", "1 tapped", "1D LUH BRO", "IM NOT CHEATING"},
            Fulcrum = {"faded than a h__", "double penjamin city", "need i say more?", "tripple penjamin city", "dabingnton town", "dabington", "penjamin", "yodie gang", "yodie", "gang", "yuuuuuuuuuuuuuup", "come in", "theres 5 things i need to tell you", "boinkers city", "yodie town", "yodieville", "faded"},
            Custom = CustomChat,
            Song = {}
        },
        PartSizes = {
            ["Head"] = Vector3.new(2, 1, 1),
            ["Torso"] = Vector3.new(2, 2, 1),
            ["Left Arm"] = Vector3.new(1, 2, 1),
            ["Right Arm"] = Vector3.new(1, 2, 1),
            ["Left Leg"] = Vector3.new(1, 2, 1),
            ["Right Leg"] = Vector3.new(1, 2, 1)
        },
        Emojis = {"ğŸ˜€", "ğŸ˜", "ğŸ˜‚", "ğŸ¤£", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜…", "ğŸ˜†", "ğŸ˜Š", "ğŸ˜", "ğŸ™‚", "ğŸ¤—", "ğŸ¤©", "ğŸ¤”", "ğŸ¤¨", "ğŸ˜", "ğŸ˜‘", "ğŸ˜¶", "ğŸ™„", "ğŸ˜£", "ğŸ˜¥", "ğŸ˜®", "ğŸ¤", "ğŸ˜¯", "ğŸ˜ª", "ğŸ˜«", "ğŸ¥±", "ğŸ˜´", "ğŸ˜Œ", "ğŸ˜›", "ğŸ˜œ", "ğŸ˜", "ğŸ˜’", "ğŸ¤¤", "ğŸ˜“", "ğŸ˜”", "ğŸ˜•", "ğŸ™ƒ", "ğŸ¤‘", "ğŸ˜²", "ğŸ™", "ğŸ˜–", "ğŸ˜", "ğŸ˜Ÿ", "ğŸ˜¤", "ğŸ˜¢", "ğŸ˜­", "ğŸ˜¦", "ğŸ˜§", "ğŸ˜¨", "ğŸ˜©", "ğŸ¤¯", "ğŸ˜¬", "ğŸ˜°", "ğŸ˜±", "ğŸ¥µ", "ğŸ¥¶", "ğŸ˜³", "ğŸ¤ª", "ğŸ˜µ", "ğŸ¥´", "ğŸ˜ ", "ğŸ˜¡", "ğŸ¤¬", "ğŸ˜·", "ğŸ¤’", "ğŸ¤•", "ğŸ¤¢", "ğŸ¤®", "ğŸ¤§", "ğŸ˜‡", "ğŸ¥³", "ğŸ¥º", "ğŸ¤ ", "ğŸ¤¡", "ğŸ¤¥", "ğŸ¤«", "ğŸ¤­", "ğŸ§", "ğŸ¤“", "ğŸ˜ˆ", "ğŸ‘¿", "ğŸ‘¹", "ğŸ‘º", "ğŸ’€", "â˜ ", "ğŸ‘»", "ğŸ‘½", "ğŸ‘¾", "ğŸ¤–", "ğŸ’©", "ğŸ˜º", "ğŸ˜¸", "ğŸ˜¹", "ğŸ˜¼", "ğŸ˜½", "ğŸ™€", "ğŸ˜¿", "ğŸ˜¾", "ğŸ±â€", "ğŸ‘¤", "ğŸ±â€", "ğŸ", "ğŸ±â€ğŸ’»", "ğŸ±â€", "ğŸ‰", "ğŸ±â€", "ğŸ‘“", "ğŸ±â€ğŸš€", "ğŸ™ˆ", "ğŸ™‰", "ğŸ™Š", "ğŸµ", "ğŸ¶", "ğŸº", "ğŸ±", "ğŸ¦", "ğŸ¯", "ğŸ¦’", "ğŸ¦Š", "ğŸ¦", "ğŸ®", "ğŸ·", "ğŸ—", "ğŸ­", "ğŸ¹", "ğŸ°", "ğŸ»", "ğŸ²", "ğŸ”", "ğŸ¦„", "ğŸ´", "ğŸ¦“", "ğŸ¸", "ğŸ¼", "ğŸ¨", "ğŸ½", "ğŸ¾", "ğŸ’", "ğŸ¦", "ğŸ¦§", "ğŸ¦®", "ğŸ•â€", "ğŸ¦º", "ğŸ©", "ğŸ¦›", "ğŸ¦", "ğŸ¦Œ", "ğŸ", "ğŸ†", "ğŸ…", "ğŸˆ", "ğŸ•", "ğŸ‘€", "ğŸ‘", "ğŸ§ ", "ğŸ¦¾", "ğŸ¦¿", "ğŸ‘£", "ğŸ¤º", "ğŸ•·", "ğŸ•¸", "ğŸ…", "ğŸ‘²", "ğŸ‘©â€ğŸ“", "ğŸ‘¨â€ğŸ“", "ğŸ†", "ğŸ‡", "ğŸ¨", "ğŸª", "ğŸ•¶", "ğŸ‘“", "ğŸ¥½", "ğŸ€", "ğŸ¥", "ğŸ", "âš¾", "âš½", "ğŸ’", "ğŸ’", "ğŸ’„", "ğŸˆ", "ğŸ‰", "ğŸ±", "ğŸ”Š", "ğŸ”‰", "ğŸ”ˆ", "ğŸ“¢", "ğŸ“£", "ğŸ§", "ğŸª•", "ğŸ¸", "ğŸº", "ğŸ·", "ğŸ»", "âœ‚", "ğŸ“", "ğŸ“", "ğŸ—ƒ", "ğŸ•", "ğŸ”", "ğŸŸ", "ğŸŒ­", "ğŸ¿", "ğŸ§‚", "ğŸ¥“", "ğŸŒ®", "ğŸŒ¯", "ğŸ’"} ,
        Symbols = {"$", "!", "Â£", "%", "^", "&", "*", "(", ")", "_", "-", "+", "=", "[", "]", "{", "}", "@", ":", ";", "/", "?", "<", ">"}
    },
    Safe = true,
    Version = "Universal",
    Language = "Eng",
    Account = {
        Username = (lgVarsTbl and lgVarsTbl["DiscordUsername"] or "Matas"),
        UserID = 1
    }
}
-- // Variables
local ReplicatedStorage, UserInputService, TeleportService, HttpService, RunService, Workspace, Lighting, CoreGui, Players, Teams, Stats = game:GetService("ReplicatedStorage"), game:GetService("UserInputService"), game:GetService("TeleportService"), game:GetService("HttpService"), game:GetService("RunService"), game:GetService("Workspace"), game:GetService("Lighting"), game:GetService("CoreGui"), game:GetService("Players"), game:GetService("Teams"), game:GetService("Stats")
--
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local Network = settings():GetService("NetworkSettings")
--
local Client = Players.LocalPlayer
--
local ResetMemoryCategory, SetMemoryCategory, SetUpvalueName, SetMetatable, ProfileBegin, GetMetatable, GetConstants, GetRegistry, GetConstant, SetConstant, ValidLevel, LoadModule, SetUpvalue, ProfileEnd, GetProtos, GetLocals, Traceback, SetStack, GetLocal, DumpHeap, GetProto, SetLocal, GetStack, GetFenv, GetInfo, Info = debug.resetmemorycategory, debug.setmemorycategory, debug.setupvaluename, debug.setmetatable, debug.profilebegin, debug.getmetatable, debug.getconstants, debug.getregistry, debug.getconstant, debug.setconstant, debug.validlevel, debug.loadmodule, debug.setupvalue, debug.profileend, debug.getprotos, debug.getlocals, debug.traceback, debug.setstack, debug.getlocal, debug.dumpheap, debug.getproto, debug.setlocal, debug.getstack, debug.getfenv, debug.getinfo, debug.info
local RandomSeed, Random, Frexp, Floor, Atan2, Log10, Noise, Round, Ldexp, Clamp, Sinh, Sign, Asin, Acos, Fmod, Huge, Tanh, Sqrt, Atan, Modf, Ceil, Cosh, Deg, Min, Log, Cos, Exp, Max, Rad, Abs, Pow, Sin, Tan, Pi = math.randomseed, math.random, math.frexp, math.floor, math.atan2, math.log10, math.noise, math.round, math.ldexp, math.clamp, math.sinh, math.sign, math.asin, math.acos, math.fmod, math.huge, math.tanh, math.sqrt, math.atan, math.modf, math.ceil, math.cosh, math.deg, math.min, math.log, math.cos, math.exp, math.max, math.rad, math.abs, math.pow, math.sin, math.tan, math.pi
local Foreachi, Isfrozen, Foreach, Insert, Remove, Concat, Freeze, Create, Unpack, Clear, Clone, Maxn, Move, Pack, Find, Sort, Getn = table.foreachi, table.isfrozen, table.foreach, table.insert, table.remove, table.concat, table.freeze, table.create, table.unpack, table.clear, table.clone, table.maxn, table.move, table.pack, table.find, table.sort, table.getn
local PackSize, Reverse, SUnpack, Gmatch, Format, Lower, Split, Match, Upper, Byte, Char, Pack, Gsub, SFind, Rep, Sub, Len = string.packsize, string.reverse, string.unpack, string.gmatch, string.format, string.lower, string.split, string.match, string.upper, string.byte, string.char, string.pack, string.gsub, string.find, string.rep, string.sub, string.len
local Countlz, Rrotate, Replace, Lrotate, Countrz, Arshift, Extract, Lshift, Rshift, Btest, Band, Bnot, Bxor, Bor = bit32.countlz, bit32.rrotate, bit32.replace, bit32.lrotate, bit32.countrz, bit32.arshift, bit32.extract, bit32.lshift, bit32.rshift, bit32.btest, bit32.band, bit32.bnot, bit32.bxor, bit32.bor
local NfcNormalize, NfdNormalize, CharPattern, CodePoint, Graphemes, Offset, Codes, Char, Len = utf8.nfcnormalize, utf8.nfdnormalize, utf8.charpattern, utf8.codepoint, utf8.graphemes, utf8.offset, utf8.codes, utf8.char, utf8.len
local Isyieldable, Running, Status, Create, Resume, Close, Yield, Wrap = coroutine.isyieldable, coroutine.running, coroutine.status, coroutine.create, coroutine.resume, coroutine.close, coroutine.yield, coroutine.wrap
local Desynchronize, Synchronize, Cancel, Delay, Defer, Spawn, Wait = task.desynchronize, task.synchronize, task.cancel, task.delay, task.defer, task.spawn, task.wait
--
local DefaultChatSystemChatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
local SayMessage = DefaultChatSystemChatEvents and DefaultChatSystemChatEvents:FindFirstChild("SayMessageRequest")
--
local Storage = Instance.new("Folder");Storage.Parent = CoreGui
local Mouse = Client:GetMouse()
local Ping = Stats.PerformanceStats.Ping
local Dot = Vector3.new().Dot
-- // Preload
do -- Preload
    for Index, Value in pairs(listfiles("Atlanta/Configs/" .. Atlanta.Version)) do
        local Split = Split(Value, "\\")
        --
        if Split[2] and Sub(Split[2], -7) == "Atlanta" then
            local Name = Sub(Split[2], 0, #Split[2] - 8)
            --
            Atlanta.Configs[#Atlanta.Configs + 1] = Name
        end
    end
    --
    do -- Renders
        --
    do -- Saving
        Atlanta.Locals.FieldOfView = Workspace.CurrentCamera.FieldOfView
        Atlanta.Locals.Lighting = {}
        --
        for Index, Value in pairs({"Ambient", "OutdoorAmbient", "Brightness", "ClockTime", "ColorShift_Bottom", "ColorShift_Top", "ExposureCompensation", "FogColor", "FogEnd", "FogStart"}) do
            Atlanta.Locals.Lighting[Value] = Lighting[Value]
        end
        --
        Atlanta.Locals.FieldOfView = Workspace.CurrentCamera.FieldOfView
    end
    --
    do -- Humaniser
        if Atlanta.Locals.Sample then
            local Passed, Statement = pcall(function()
                return HttpService:JSONDecode(Atlanta.Locals.Sample)
            end)
            --
            if Passed then
                Atlanta.Locals.Humaniser.Sample = Statement
            else
                Atlanta.Locals.Sample = nil
            end
        end
    end
    --
    do -- Random Language
        Languages["Rnd"] = {}
        Languages["Mrs"] = {}
        Languages["Rev"] = {}
        --
        for Index, Value in pairs(Languages["Lt"]) do
            Languages["Rnd"][Index] = Char(math.random(100, 160))..Char(math.random(100, 160))..Char(math.random(100, 160))..Char(math.random(100, 160))..Char(math.random(100, 160))..Char(math.random(100, 160))
        end
        --
        for Index, Value in pairs(Languages["Lt"]) do
            local Str = "."
            Languages["Mrs"][Index] = Rep(Str, math.random(1, 5)) .. " " .. Rep(Str, math.random(1, 8)) .. " " .. Rep(Str, math.random(1, 5)) .. " " .. Rep(Str, math.random(1, 12))
        end
        --
        for Index, Value in pairs(Languages["Lt"]) do
            if Index ~= "[%s]  -  [Account = $ACC [$UID],  Build = $BUILD,  Ping = $PING,  FPS = $FPS]" then
                Languages["Rev"][Index] = Reverse(Index)
            end
        end
        --
        Languages["Rev"]["[%s]  -  [Account = $ACC [$UID],  Build = $BUILD,  Ping = $PING,  FPS = $FPS]"] = "[$FPS = SPF,  $PING = gniP,  $BUILD = dliuB, [$UID] $ACC = tnuoccA] = [%s]"
    end
end
-- // Functions
do -- Utility
    function Utility:GetTableIndexes(Table, Custom)
        local Table2 = {}
        --
        for Index, Value in pairs(Table) do
            Table2[Custom and Value[1] or #Table2 + 1] = Index 
        end
        --
        return Table2
    end
    --
    function Utility:ConvertTable(Table1)
        local Table2 = {}
        --
        for Index, Value in pairs(Table1) do
            Table2[typeof(Index) ~= "number" and Index or (#Table2 + 1)] = tostring(Value)
        end
        --
        return Table2
    end
    --
    function Utility:ConvertString(Value)
        if typeof(Value) == "Color3" then
            Value = Value:ToHex()
        end
        --
        return Value
    end
    --
    function Utility:Encode(Table)
        local Table2 = {}
        --
        for Index, Value in pairs(Table) do
            Table2[Index] = Utility:ConvertString(Value)
        end
        --
        return HttpService:JSONEncode(Table2)
    end
    --
    function Utility:Decode(Table)
        return HttpService:JSONDecode(Table)
    end
    --
    function Library:UpdateColor(ColorType, ColorValue)
        local ColorType = ColorType:lower()
        --
        Theme[ColorType] = ColorValue
        --
        for Index, Value in pairs(Library.colors) do
            for Index2, Value2 in pairs(Value) do
                if Value2 == ColorType then
                    Index[Index2] = Theme[Value2]
                end
            end
        end
    end
    --
    function Library:UpdateTheme(ThemeType, ThemeValue)
        if Flags["ConfigTheme_" .. ThemeType] then
            Flags["ConfigTheme_" .. ThemeType]:Set(ThemeValue)
        end
    end
    --
    function Library:LoadTheme(ThemeType)
        if Themes[ThemeType] then
            local ThemeValue = Utility:Decode(Themes[ThemeType][2])
            --
            for Index, Value in pairs(ThemeValue) do
                Library:UpdateTheme(Index, Color3.fromHex(Value)) 
            end
        end
    end
    --
    function Library:RefreshConfigList()
        Flags["ConfigConfiguration_Box"].options = Atlanta.Configs
        Flags["ConfigConfiguration_Box"].current = Clamp(Flags["ConfigConfiguration_Box"].current, 0, #Atlanta.Configs)
        Flags["ConfigConfiguration_Box"]:UpdateScroll()
    end
    --
    function Library:GetConfig()
        local Config = ""
        --
        for Index, Value in pairs(Flags) do
            if Index ~= "ConfigConfiguration_Box" and Index ~= "ConfigConfiguration_Name" then
                local Value2 = Value:Get()
                local Final = ""
                --
                if typeof(Value2) == "Color3" then
                    local Values = Value.current
                    --
                    Final = ("rgb(%s,%s,%s,%s)"):format(Values[1], Values[2], Values[3], Values[4])
                elseif typeof(Value2) == "table" and Value2.Color and Value2.Transparency then
                    local Values = Value.current
                    --
                    Final = ("rgb(%s,%s,%s,%s)"):format(Values[1], Values[2], Values[3], Values[4])
                elseif Value.mode then
                    local Values = Value.current
                    --
                    Final = ("key(%s,%s,%s)"):format(Values[1] or "nil", Values[2] or "nil", Value.mode)
                elseif (Value2 ~= nil) then
                    if typeof(Value2) == "boolean" then
                        Value2 = ("bool(%s)"):format(tostring(Value2))
                    elseif typeof(Value2) == "table" then
                        local New = "table("
                        --
                        for Index2, Value3 in pairs(Value2) do
                            New = New .. Value3 .. ","
                        end
                        --
                        if New:sub(#New) == "," then
                            New = New:sub(0, #New - 1)
                        end
                        --
                        Value2 = New .. ")"
                    elseif typeof(Value2) == "string" then
                        Value2 = ("string(%s)"):format(Value2)
                    elseif typeof(Value2) == "number" then
                        Value2 = ("number(%s)"):format(Value2)
                    end
                    --
                    Final = Value2
                end
                --
                Config = Config .. Index .. ": " .. Final .. "\n"
            end
        end
        --
        return Config .. "[ gamesneeze.cc ]"
    end
    --
    function Library:LoadConfig(Config)
        if typeof(Config) == "table" then
            for Index, Value in pairs(Config) do
                if typeof(Flags[Index]) ~= "nil" then
                    Flags[Index]:Set(Value)
                end
            end
        end
    end
    --
    function Library:PerformConfigAction(ConfigName, Action)
        if ConfigName then
            if Action == "Delete" then
                local Found = Find(Atlanta.Configs, ConfigName)
                --
                if Found then
                    Remove(Atlanta.Configs, Found) 
                    Library:RefreshConfigList()
                end
                --
                delfile(("Atlanta/Configs/%s/%s"):format(Atlanta.Version, ConfigName .. ".Atlanta"), Config)
            elseif Action == "Save" then
                local Config = Library:GetConfig()
                --
                if Config then
                    if not Find(Atlanta.Configs, ConfigName) then
                        Atlanta.Configs[#Atlanta.Configs + 1] = ConfigName
                        Library:RefreshConfigList()
                    end
                    --
                    writefile(("Atlanta/Configs/%s/%s"):format(Atlanta.Version, ConfigName .. ".Atlanta"), Config)
                end
            elseif Action == "Load" then
                local Config = readfile(("Atlanta/Configs/%s/%s"):format(Atlanta.Version, ConfigName .. ".Atlanta"))
                local Table = Split(Config, "\n")
                local Table2 = {}
                --
                if Table[#Table] == "[ gamesneeze.cc ]" then
                    Remove(Table, #Table)
                end
                --
                for Index, Value in pairs(Table) do
                    local Table3 = Split(Value, ":")
                    --
                    if Table3[1] ~= "ConfigConfiguration_Name" and #Table3 >= 2 then
                        local Value = Table3[2]:sub(2, #Table3[2])
                        --
                        if Value:sub(1, 3) == "rgb" then
                            local Table4 = Split(Value:sub(5, #Value - 1), ",")
                            --
                            Value = Table4
                        elseif Value:sub(1, 3) == "key" then
                            local Table4 = Split(Value:sub(5, #Value - 1), ",")
                            --
                            if Table4[1] == "nil" and Table4[2] == "nil" then
                                Table4[1] = nil
                                Table4[2] = nil
                            end
                            --
                            Value = Table4
                        elseif Value:sub(1, 4) == "bool" then
                            local Bool = Value:sub(6, #Value - 1)
                            --
                            Value = Bool == "true"
                        elseif Value:sub(1, 5) == "table" then
                            local Table4 = Split(Value:sub(7, #Value - 1), ",")
                            --
                            Value = Table4
                        elseif Value:sub(1, 6) == "string" then
                            local String = Value:sub(8, #Value - 1)
                            --
                            Value = String
                        elseif Value:sub(1, 6) == "number" then
                            local Number = tonumber(Value:sub(8, #Value - 1))
                            --
                            Value = Number
                        end
                        --
                        Table2[Table3[1]] = Value
                    end
                end
                -- 
                Library:LoadConfig(Table2)
            end
        end
    end
    --
    function Library:UpdateHue()
        if (tick() - Atlanta.Locals.ShiftTick) >= (1 / 60) then
            Atlanta.Locals.Shift = Atlanta.Locals.Shift + 0.01
            --
            if Flags["ConfigTheme_AccentEffect"]:Get() == "Rainbow" then
                Library:UpdateColor("Accent", Color3.fromHSV(Math:Shift(Atlanta.Locals.Shift), 0.55, 1))
            elseif Flags["ConfigTheme_AccentEffect"]:Get() == "Shift" then
                local Hue, Saturation, Value = Flags["ConfigTheme_Accent"]:Get():ToHSV()
                --
                Library:UpdateColor("Accent", Color3.fromHSV(Math:Shift(Hue + (Math:Shift(Atlanta.Locals.Shift) * (Flags["ConfigTheme_EffectLength"]:Get() / 360))), Saturation, Value))
            elseif Flags["ConfigTheme_AccentEffect"]:Get() == "Reverse Shift" then
                local Hue, Saturation, Value = Flags["ConfigTheme_Accent"]:Get():ToHSV()
                --
                Library:UpdateColor("Accent", Color3.fromHSV(Math:Shift(Clamp(Hue - (Math:Shift(Atlanta.Locals.Shift) * (Flags["ConfigTheme_EffectLength"]:Get() / 360)), 0, 9999)), Saturation, Value))
            end
            --
            Atlanta.Locals.ShiftTick = tick()
        end
    end
    --
    function Utility:ClampString(String, Length, Font)
        local Font = (Font or 2)
        local Split = String:split("\n")
        --
        local Clamped = ""
        --
        for Index, Value2 in pairs(Split) do
            if (Index * 13) <= Length then
                Clamped = Clamped .. Value2 .. (Index == #Split and "" or "\n")
            end
        end
        --
        return (Clamped ~= String and (Clamped == "" and "" or Clamped:sub(0, #Clamped - 1) .. " ...") or Clamped)
    end
    --
  
    --
    function Utility:ThreadFunction(Func, Name, ...)
        local Func = Name and function()
            local Passed, Statement = pcall(Func)
            --
            if not Passed and not Atlanta.Safe then
                warn("Atlanta:\n", "              " .. Name .. ":", Statement)
            end
        end or Func
       
    end
    --
    function Utility:SafeCheck(Text)
        local Safe = Text:lower()
        --
        for Index, Value in pairs(Atlanta.Locals.BadWords) do Safe = Safe:gsub(Value, "_") end
        --
        return Safe
    end
    --
    function Utility:TableToString(Table)
        if #Table > 1 then
            local Text = ""
            --
            for Index, Value in pairs(Table) do
                Text = Text .. Value .. "\n"
            end
            --
            return Text:sub(0, #Text - 1)
        else
            return Table[1]
        end
    end
    --
    function Utility:MousePosition(Offset)
        if Offset then
            return UserInputService:GetMouseLocation() + Atlanta:CursorOffset()
        else
            return UserInputService:GetMouseLocation()
        end
    end
    --
    function Utility:Console(Action, ...)
        if not Atlanta.Safe then
            Action(...)
        end
    end
end
--
do -- Visualisation
    function Visualisation:CreateClone(Character)
        local Clone = Utility:Instance("Model", {
            Name = "Visualisation",
            Parent = Workspace
        })
        --
        local Head = Character:FindFirstChild("Head")
        --
        local PartsTable = {}
        --
        for Index, Value in pairs(Character:GetChildren()) do
            if Value:IsA("BasePart") and (Value.Name == "Head" or Value.Name:find("Arm") or Value.Name:find("Torso") or Value.Name:find("Leg") or Value.Name:find("Hand") or Value.Name:find("Foot")) then
                local Part = Utility:Instance("Part", {
                    Name = Value.Name,
                    Color = Color3.fromRGB(112, 107, 139),
                    Size = Value.Size * 1.025,
                    CFrame = Value.CFrame,
                    CanCollide = false,
                    Transparency = 0,
                    Anchored = true,
                    Material = "SmoothPlastic",
                    BackSurface = "Smooth",
                    BottomSurface = "Smooth",
                    FrontSurface = "Smooth",
                    LeftSurface = "Smooth",
                    RightSurface = "Smooth",
                    TopSurface = "Smooth",
                    Shape = (Value.Name == "Head" and "Cylinder" or "Block"),
                    Parent = Clone
                })
                --
                for Index, Value in pairs({"Back", "Bottom", "Front", "Left", "Right", "Top"}) do
                    local Texture = Utility:Instance("Texture", {
                        Color3 = Color3.fromRGB(112, 107, 139),
                        OffsetStudsU = 0,
                        OffsetStudsV = 0,
                        StudsPerTileU = 12.5,
                        StudsPerTileV = 12.5,
                        Transparency = 0.5,
                        Face = Value,
                        Parent = Part
                    })
                end
                --
                PartsTable[Value] = Part
            end
        end
        --
        Visualisation.Character = PartsTable
    end
    --
    function Visualisation:Update(FakeLagging)
        local Object, Humanoid, RootPart = Atlanta:ValidateClient(Client)
        --
        if RootPart then
            if Visualisation.Character then
                local VisualisationColor, VisualisationTransparency = Flags["PlayersLocal_VisualisationColor"]:Get().Color, Flags["PlayersLocal_VisualisationColor"]:Get().Transparency
                local VisualisationTransparency2 = Clamp(VisualisationTransparency + 0.25, 0, 1)
                local ServerPosition = Flags["PlayersLocal_ServerPosition"]:Get()
                local VisualisationMaterial = Flags["PlayersLocal_VisualisationMaterial"]:Get()
                --
                if FakeLagging then
                    for Index, Perform in pairs(Visualisation.LastUpdate) do
                        if ServerPosition then Delay(Atlanta:GetLatency() * 1.75, Perform) else Perform() end
                    end
                else
                    Visualisation.LastUpdate = {}
                    --
                    for Index, Value in pairs(Visualisation.Character) do
                        if Index then
                            local OldCFrame = Index.CFrame
                            --
                            Value.Material = (VisualisationMaterial == "Ghost" and "ForceField" or VisualisationMaterial == "Smooth Plastic" and "SmoothPlastic" or VisualisationMaterial == "Animated" and "Neon" or VisualisationMaterial)
                            Value.Color = VisualisationColor
                            Value.Transparency = VisualisationTransparency
                            --
                            for Index2, Value2 in pairs(Value:GetChildren()) do
                                if Value2:IsA("Texture") then
                                    if VisualisationMaterial == "Animated" then
                                        Value2.Color3 = VisualisationColor
                                        Value2.Transparency = VisualisationTransparency2
                                        Value2.Texture = Format("rbxasset://textures/water/normal_%02d.dds", Visualisation.Texture)
                                    else
                                        Value2.Transparency = 1
                                    end
                                end
                            end
                            --
                            local Perform = function()
                                local Radius = (Index.Name == "Head" and ((Index.Size.X * (Value:FindFirstChildOfClass("WrapTarget") and 0.45 or 0.275)) + 0.1))
                                --
                                Value.Size = Index.Name == "Head" and Vector3.new(Index.Size.Y, Radius * 2, Radius * 2) or (Index.Size * 0.99)
                                Value.CFrame = OldCFrame * CFrame.Angles(0, 0, Index.Name == "Head" and Rad(90) or 0)
                            end
                            --
                            Visualisation.LastUpdate[Value] = Perform
                            --
                            if ServerPosition then Delay(Atlanta:GetLatency() * 1.75, Perform) else Perform() end
                        else
                            Value:Remove()
                        end
                    end
                end
                --
                Visualisation.Texture = Visualisation.Texture + 1
                --
                if Visualisation.Texture > 25 then
                    Visualisation.Texture = 1
                end
            end
        end
    end
end
--
do -- Camera
    function Camera:AngleEdge(Angle, Inset)
        local ScreenSize = Workspace.CurrentCamera.ViewportSize
        local Sine = Sin(Angle)
        local Cosine = Cos(Angle)
        local Slope = (Sine / Cosine)
        local EdgeX = ScreenSize.X - Inset
        local EdgeY = ScreenSize.Y - Inset
        --
        if Sine < 0 then EdgeY = Inset end
        if Cosine < 0 then EdgeX = Inset end
        --
        local Height = (Slope * EdgeX) + (ScreenSize.y / 2) - Slope * (ScreenSize.x / 2)
        --
        return (Height > 0 and Height < ScreenSize.Y - Inset) and Vector2.new(EdgeX, Height) or Vector2.new((EdgeY - ScreenSize.Y / 2 + Slope * (ScreenSize.X / 2)) / Slope, EdgeY)
    end
end
--
do -- Color
	function Color:Multiply(Color, Multiplier)
		return Color3.new(Color.R * Multiplier, Color.G * Multiplier, Color.B * Multiplier)
	end
    --
	function Color:Add(Color, Addition)
		return Color3.new(Color.R + Addition, Color.G + Addition, Color.B + Addition)
	end
    --
    function Color:Lerp(Value, MinColor, MaxColor)
        if Value <= 0 then return MaxColor end
        if Value >= 100 then return MinColor end
        --
        return Color3.new(
            MaxColor.R + (MinColor.R - MaxColor.R) * Value,
            MaxColor.G + (MinColor.G - MaxColor.G) * Value,
            MaxColor.B + (MinColor.B - MaxColor.B) * Value
        )
    end
end
--
do -- Math
    do -- Conversions
        Math.Conversions["Studs"] = {
            Conversion = function(Studs)
                return Studs
            end,
            Measurement = "st",
            Round = function(Number)
                return Round(Number)
            end
        }
        --
        Math.Conversions["Meters"] = {
            Conversion = function(Studs)
                return Studs * 0.28
            end,
            Measurement = "m",
            Round = function(Number)
                return Round(Number * 10) / 10
            end
        }
        --
        Math.Conversions["Centimeters"] = {
            Conversion = function(Studs)
                return Studs * 28
            end,
            Measurement = "cm",
            Round = function(Number)
                return Round(Number)
            end
        }
        --
        Math.Conversions["Kilometers"] = {
            Conversion = function(Studs)
                return Studs * 0.00028
            end,
            Measurement = "km",
            Round = function(Number)
                return Round(Number * 1000) / 1000
            end
        }
        --
        Math.Conversions["Millimeters"] = {
            Conversion = function(Studs)
                return Studs * 280
            end,
            Measurement = "mm",
            Round = function(Number)
                return Round(Number)
            end
        }
        --
        Math.Conversions["Micrometers"] = {
            Conversion = function(Studs)
                return Studs * 280000
            end,
            Measurement = "Î¼m",
            Round = function(Number)
                return Round(Number)
            end
        }
        --
        Math.Conversions["Inches"] = {
            Conversion = function(Studs)
                return Studs * 11.0236224
            end,
            Measurement = [['']],
            Round = function(Number)
                return Round(Number)
            end
        }
        --
        Math.Conversions["Miles"] = {
            Conversion = function(Studs)
                return Studs * 0.000173983936
            end,
            Measurement = "mi",
            Round = function(Number)
                return Round(Number * 10000) / 10000
            end
        }
        --
        Math.Conversions["Nautical Miles"] = {
            Conversion = function(Studs)
                return Studs * 0.0005399568
            end,
            Measurement = "nmi",
            Round = function(Number)
                return Round(Number * 10000) / 10000
            end
        }
        --
        Math.Conversions["Yards"] = {
            Conversion = function(Studs)
                return Studs * 0.30621164
            end,
            Measurement = "yd",
            Round = function(Number)
                return Round(Number * 10) / 10
            end
        }
        --
        Math.Conversions["Feet"] = {
            Conversion = function(Studs)
                return Studs * 0.9186352
            end,
            Measurement = "ft",
            Round = function(Number)
                return Round(Number)
            end
        }
    end
    --
    function Math:RotatePoint(Point, Radians)
        local Unit = Point.Unit
        --
        local Sine = Sin(Radians)
        local Cosine = Cos(Radians)
        --
        return Vector2.new((Cosine * Unit.X) - (Sine * Unit.Y), (Sine * Unit.X) + (Cosine * Unit.Y)).Unit * Point.Magnitude
    end
    --
    function Math:RoundVector(Vector)
        return Vector2.new(Round(Vector.X), Round(Vector.Y))
    end
    --
    function Math:Shift(Number)
        return Acos(Cos(Number * Pi)) / Pi
    end
    --
    function Math:Conversion(Studs, Conversion)
        local Conversion = Math.Conversions[Conversion]
        --
        local Converted = Conversion.Conversion(Studs)
        local Measurement = Conversion.Measurement
        local Rounded = Conversion.Round(Converted)
        --
        return Converted, Measurement, Rounded
    end
    --
    function Math:Random(Number)
        return Random(-Number, Number)
    end
    --
    function Math:RandomVec3(X, Y, Z)
        return Vector3.new(Math:Random(X), Math:Random(Y), Math:Random(Z))
    end
end
--
do -- Tween
    Tween.EasingStyles = {
        [Enum.EasingStyle.Linear] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return Delta
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                return Delta
            end
        },
        [Enum.EasingStyle.Cubic] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 3
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return ((Delta - 1) ^ 3) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (4 * Delta ^ 3)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return (4 * (Delta - 1) ^ 3) + 1
                end
            end
        },
        [Enum.EasingStyle.Quad] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 2
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return (-(Delta - 1) ^ 2) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (2 * Delta ^ 2)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return -(2 * (Delta - 1) ^ 2) + 1
                end
            end
        },
        [Enum.EasingStyle.Quart] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 4
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return (-(Delta - 1) ^ 4) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (8 * Delta ^ 4)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return -(8 * (Delta - 1) ^ 4) + 1
                end
            end
        },
        [Enum.EasingStyle.Quint] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Delta ^ 5
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return ((Delta - 1) ^ 5) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (16 * Delta ^ 5)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return (16 * (Delta - 1) ^ 5) + 1
                end
            end
        },
        [Enum.EasingStyle.Sine] = {
            [Enum.EasingDirection.In] = function(Delta)
                return Sin(((Pi / 2) * Delta) - (Pi / 2)) + 1
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return Sin((Pi / 2) * Delta)
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                return (0.5 * Sin((Pi * Delta) - (Pi / 2))) + 0.5
            end
        },
        [Enum.EasingStyle.Exponential] = {
            [Enum.EasingDirection.In] = function(Delta)
                return (2 ^ ((10 * Delta) - 10)) - 0.001
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return 1.001 * (-2 ^ -(10 * Delta)) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return 0.5 * (2 ^ ((20 * Delta) - 10)) - 0.0005
                elseif 0.5 <= Delta and Delta <= 1 then
                    return 0.50025 * (-2 ^ (-(20 * Delta) + 10)) + 1
                end
            end
        },
        [Enum.EasingStyle.Back] = {
            [Enum.EasingDirection.In] = function(Delta)
                return (Delta * Delta) * (Delta * (1.70158 + 1) - 1.70158)
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return ((Delta - 1) ^ 2) * ((Delta - 1) * (1.70158 + 1) + 1.70158) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return (2 * (Delta * Delta)) * ((2 * Delta) * (2.5949095 + 1) - 2.5949095)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return (0.5 * ((2 * Delta) - 2) ^ 2) * (((2 * Delta) - 2) * (2.5949095 + 1) + 2.5949095) + 1
                end
            end
        },
        [Enum.EasingStyle.Bounce] = {
            [Enum.EasingDirection.In] = function(Delta)
                if 0 <= Delta and Delta <= (1 / 2.75) then
                    return 7.5625 * (Delta * Delta)
                elseif (1 / 2.75) <= Delta and Delta <= (2 / 2.75) then
                    return 7.5625 * (Delta - (1.5 / 2.75)) ^ 2 + 0.75
                elseif (2 / 2.75) <= Delta and Delta <= (2.5 / 2.75) then
                    return 7.5625 * (Delta - (2.25 / 2.75)) ^ 2 + 0.9375
                elseif (2.5 / 2.75) <= Delta and Delta <= 1 then
                    return 7.5625 * (Delta - (2.625 / 2.75)) ^ 2 + 0.984375
                end
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                if 0 <= Delta and Delta <= (0.25 / 2.75) then
                    return -7.5625 * (1 - Delta - (2.625 / 2.75)) ^ 2 + 0.015625
                elseif (0.25 / 2.75) <= Delta and Delta <= (0.75 / 2.75) then
                    return -7.5625 * (1 - Delta - (2.25 / 2.75)) ^ 2 + 0.0625
                elseif (0.75 / 2.75) <= Delta and Delta <= (1.75 / 2.75) then
                    return -7.5625 * (1 - Delta - (1.5 / 2.75)) ^ 2 + 0.25
                elseif (1.75 / 2.75) <= Delta and Delta <= 1 then
                    return 1 - 7.5625 * (1 - Delta) ^ 2
                end
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= (0.125 / 2.75) then
                    return 0.5 * (-7.5625 * (1 - (2 * Delta) - (2.625 / 2.75)) ^ 2 + 0.015625)
                elseif (0.125 / 2.75) <= Delta and Delta <= (0.375 / 2.75) then
                    return 0.5 * (-7.5625 * (1 - (2 * Delta) - (2.25 / 2.75)) ^ 2 + 0.0625)
                elseif (0.375 / 2.75) <= Delta and Delta <= (0.875 / 2.75) then
                    return 0.5 * (-7.5625 * (1 - (2 * Delta) - (1.5 / 2.75)) ^ 2 + 0.25)
                elseif (0.875 / 2.75) <= Delta and Delta <= 0.5 then
                    return 0.5 * (1 - 7.5625 * (1 - (2 * Delta)) ^ 2)
                elseif 0.5 <= Delta and Delta <= (1.875 / 2.75) then
                    return 0.5 + 3.78125 * ((2 * Delta) - 1) ^ 2
                elseif (1.875 / 2.75) <= Delta and Delta <= (2.375 / 2.75) then
                    return 3.78125 * ((2 * Delta) - (4.25 / 2.75)) ^ 2 + 0.875
                elseif (2.375 / 2.75) <= Delta and Delta <= (2.625 / 2.75) then
                    return 3.78125 * ((2 * Delta) - (5 / 2.75)) ^ 2 + 0.96875
                elseif (2.625 / 2.75) <= Delta and Delta <= 1 then
                    return 3.78125 * ((2 * Delta) - (5.375 / 2.75)) ^ 2 + 0.9921875
                end
            end
        },
        [Enum.EasingStyle.Elastic] = {
            [Enum.EasingDirection.In] = function(Delta)
                return (-2 ^ (10 * (Delta - 1))) * Sin(((2 * Pi) * (Delta - 1 - (0.3 / 4))) / 0.3)
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return (2 ^ (-10 * Delta)) * Sin(((2 * Pi) * (Delta - (0.3 / 4))) / 0.3) + 1
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return -0.5 * (2 ^ ((20 * Delta) - 10)) * Sin(((2 * Pi) * ((2 * Delta) - 1.1125)) / 0.45)
                elseif 0.5 <= Delta and Delta <= 1 then
                    return 0.5 * (2 ^ ((-20 * Delta) + 10)) * Sin(((2 * Pi) * ((2 * Delta) - 1.1125)) / 0.45) + 1
                end
            end
        },
        [Enum.EasingStyle.Circular] = {
            [Enum.EasingDirection.In] = function(Delta)
                return -Sqrt(1 - Delta ^ 2) + 1
            end,
            [Enum.EasingDirection.Out] = function(Delta)
                return Sqrt(-(Delta - 1) ^ 2 + 1)
            end,
            [Enum.EasingDirection.InOut] = function(Delta)
                if 0 <= Delta and Delta <= 0.5 then
                    return -Sqrt(-Delta ^ 2 + 0.25) + 0.5
                elseif 0.5 <= Delta and Delta <= 1 then
                    return Sqrt(-(Delta - 1) ^ 2 + 0.25) + 0.5
                end
            end
        }
    }
end
--
do -- Chat
    function Chat:SendMessage(Message)
        if Message and Message ~= "" and Message ~= " " and SayMessage then
            SayMessage:FireServer(Message, "All")
        end
    end
    --
    function Chat:GenerateText()
        local Type = Flags["MiscChat_Type"]:Get()
        local Strings = Atlanta.Locals.Strings[Type]
        local String = ""
        --
        if Strings and typeof(Strings) == "table" and #Strings > 0 then
            if Type == "Song" then
                if Strings and typeof(Strings) == "table" and #Strings > 0 then
                    local Symbols = Flags["MiscChat_Symbols"]:Get()
                    --
                    local SymbolAmmount = Random(0, 6)
                    --
                    local First = Atlanta.Locals.Symbols[Random(1, #Atlanta.Locals.Symbols)]
                    local Second = Atlanta.Locals.Symbols[Random(1, #Atlanta.Locals.Symbols)]
                    --
                    String = (Symbols and Rep(First, SymbolAmmount) or "") .. Strings[Atlanta.Locals.SongQueue] .. (Symbols and Rep(Second, SymbolAmmount) or "")
                    --
                    if Flags["MiscChat_Emojis"]:Get() then
                        for Index = 1, Random(0, 8) do
                            if Random(1, 2) == 1 then
                                String = String .. Atlanta.Locals.Emojis[Random(1, #Atlanta.Locals.Emojis)]
                            else
                                String = Atlanta.Locals.Emojis[Random(1, #Atlanta.Locals.Emojis)] .. String
                            end
                        end
                    end
                    --
                    if (Atlanta.Locals.SongQueue + 1) > #Strings then
                        Atlanta.Locals.SongQueue = 1
                    else
                        Atlanta.Locals.SongQueue = Atlanta.Locals.SongQueue + 1
                    end
                end
            else
                if Flags["MiscChat_Multiple"]:Get() then
                    for Index = 1, Random(4, 8) do
                        local Symbols = Flags["MiscChat_Symbols"]:Get()
                        --
                        local SymbolAmmount = Random(0, 6)
                        --
                        local First = Atlanta.Locals.Symbols[Random(1, #Atlanta.Locals.Symbols)]
                        local Second = Atlanta.Locals.Symbols[Random(1, #Atlanta.Locals.Symbols)]
                        --
                        String = String .. (Symbols and Rep(First, SymbolAmmount) or "") .. Strings[Random(1, #Strings)] .. (Symbols and Rep(Second, SymbolAmmount) or "") .. " "
                        --
                        if Flags["MiscChat_Emojis"]:Get() then
                            for Index = 1, Random(0, 3) do
                                String = String .. Atlanta.Locals.Emojis[Random(1, #Atlanta.Locals.Emojis)]
                            end
                        end
                    end
                else
                    local Symbols = Flags["MiscChat_Symbols"]:Get()
                    --
                    local SymbolAmmount = Random(0, 6)
                    --
                    local First = Atlanta.Locals.Symbols[Random(1, #Atlanta.Locals.Symbols)]
                    local Second = Atlanta.Locals.Symbols[Random(1, #Atlanta.Locals.Symbols)]
                    --
                    String = (Symbols and Rep(First, SymbolAmmount) or "") .. Strings[Random(1, #Strings)] .. (Symbols and Rep(Second, SymbolAmmount) or "")
                    --
                    if Flags["MiscChat_Emojis"]:Get() then
                        for Index = 1, Random(0, 8) do
                            if Random(1, 2) == 1 then
                                String = String .. Atlanta.Locals.Emojis[Random(1, #Atlanta.Locals.Emojis)]
                            else
                                String = Atlanta.Locals.Emojis[Random(1, #Atlanta.Locals.Emojis)] .. String
                            end
                        end
                    end
                end
            end
            --
            return String:sub(0, 200)
        end
    end
    --
    function Chat:AttemptSend()
        local Tick = tick()
        --
        if Flags["MiscChat_ChatSpam"]:Get() and (Tick - Chat.LastTick) >= Flags["MiscChat_Delay"]:Get() then
            Chat.LastTick = Tick
            --
            Chat:SendMessage(Chat:GenerateText())
        end
    end
    --
    function Chat:GenerateSong(Name)
        local Split = Name:split(":")
        --
        if Split and typeof(Split) == "table" and #Split >= 2 then
            local Artist = Split[1]:lower():gsub("[^%w]+", "")
            local Song = Split[2]:lower():gsub("[^%w]+", "")
            --
            local Passed, Statement = pcall(function()
                return game:HttpGet("https://www.azlyrics.com/lyrics/" .. Artist .. "/" .. Song .. ".html")
            end)
            --
            if Passed then
                local Filter = Statement:split("<!-- Usage of azlyrics.com content by any third-party lyrics provider is prohibited by our licensing agreement. Sorry about that. -->")[2]
                local Data = Filter:sub(0, Filter:find("</div>") - 1):gsub("[\n\t]+", ""):split("<br>")
                local Final = {}
                --
                for Index, Value in pairs(Data) do
                    local Safe = Utility:SafeCheck(Value):gsub("&quot;", ""):gsub("amp;", "")
                    --
                    if Safe and typeof(Safe) == "string" and Safe ~= "" and Safe ~= " " then
                        Final[#Final + 1] = Safe
                    end
                end
                --
                if Final and #Final > 0 then
                    Final[1] = Final[1]:sub(2)
                    --
                    Atlanta.Locals.SongQueue = 1
                    Atlanta.Locals.Strings.Song = Final
                end
            end
        end
    end
end
--
do -- Languages
    function Languages:GetTranslate(Word)
        for Index, Value in pairs(Languages[Atlanta.Language]) do
            if Value == Word then
                return Index
            end
        end
        --
        return Word
    end
    --
    function Languages:GetTranslation(Word)
        return (Languages[Atlanta.Language][Word] or Word)
    end
end
--
do -- Atlanta
    function Atlanta:Unload()
        Atlanta.Locals.Window:Fade()
        --
        Wait(0.25)
        --
        Visuals:Unload()
        --
        Wait(0.25)
        --
        Storage:Remove()
        RunService:UnbindFromRenderStep("Desync")
        Atlanta.Locals.Window:Unload()
    end
    --
    function Atlanta:GetCharacter(Player)
        return Player.Character
    end
    --
    function Atlanta:GetHumanoid(Player, Character)
        return Character:FindFirstChildOfClass("Humanoid")
    end
    --
    function Atlanta:GetHealth(Player, Character, Humanoid)
        if Humanoid then
            return Clamp(Humanoid.Health, 0, Humanoid.MaxHealth), Humanoid.MaxHealth
        end
    end
    --
    function Atlanta:GetJumpPower(Player, Chareacter, Humanoid)
        return Humanoid.JumpPower
    end
    --
    function Atlanta:GetRootPart(Player, Character, Humanoid)
        return Humanoid.RootPart
    end
    --
    function Atlanta:GetLatency()
        return (Ping:GetValue() / 1000)
    end
    --
    function Atlanta:GetTeam(Player)
        return Player.Team
    end
    --
    function Atlanta:GetPlayerParent(Player)
        return Player.Parent
    end
    --
    function Atlanta:CheckTeam(Player1, Player2)
        if Library.Relations[Player2.UserId] == "Friend" then
            return false
        elseif Library.Relations[Player2.UserId] == "Enemy" or Library.Relations[Player2.UserId] == "Priority" then
            return true
        end
        --
        return Flags["SettingsMain_Deathmatch"]:Get() or (Atlanta:GetTeam(Player1) ~= Atlanta:GetTeam(Player2))
    end
    --
    function Atlanta:GetIgnore(Unpacked)
        return
    end
    --
    function Atlanta:GetOrigin(Origin)
        if Origin == "Head" then
            local Object, Humanoid, RootPart = Atlanta:ValidateClient(Client)
            local Head = Object:FindFirstChild("Head")
            --
            if Head and Head:IsA("RootPart") then
                return Head.CFrame.Position
            end
        elseif Origin == "Torso" then
            local Object, Humanoid, RootPart = Atlanta:ValidateClient(Client)
            --
            if RootPart then
                return RootPart.CFrame.Position
            end
        end
        --
        return Workspace.CurrentCamera.CFrame.Position
    end
    --
    function Atlanta:GetBodyParts(Character, RootPart, Indexes, Hitboxes)
        local Parts = {}
        local Hitboxes = Hitboxes or {"Head", "Torso", "Arms", "Legs"}
        --
        for Index, Part in pairs(Character:GetChildren()) do
            if Part:IsA("BasePart") and Part ~= RootPart then
                if Find(Hitboxes, "Head") and Part.Name:lower():find("head") then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif Find(Hitboxes, "Torso") and Part.Name:lower():find("torso") then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif Find(Hitboxes, "Arms") and Part.Name:lower():find("arm") then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif Find(Hitboxes, "Legs") and Part.Name:lower():find("leg") then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif (Find(Hitboxes, "Arms") and Part.Name:lower():find("hand")) or (Find(Hitboxes, "Legs ") and Part.Name:lower():find("foot")) then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                end
            end
        end
        --
        return Parts
    end
    --
    function Atlanta:ClientAlive(Player, Character, Humanoid)
        local Health, MaxHealth = Atlanta:GetHealth(Player, Character, Humanoid)
        --
        return (Health > 0)
    end
    --
    function Atlanta:ValidateClient(Player)
        local Object = Atlanta:GetCharacter(Player)
        local Humanoid = (Object and Atlanta:GetHumanoid(Player, Object))
        local RootPart = (Humanoid and Atlanta:GetRootPart(Player, Object, Humanoid))
        --
        return Object, Humanoid, RootPart
    end
    --
    function Atlanta:OnGround(Character, RootPart)
        local Raycast = Ray.new(RootPart.Position, -(RootPart.CFrame.UpVector * 100))
        local Hit, Position = workspace:FindPartOnRay(Raycast, Character)
        --
        if Hit and Position then
            return Ceil((RootPart.Position - Position).Magnitude) <= 2
        end
    end
    --
    function Atlanta:DistanceFromGround(Character, RootPart)
        local Raycast = Ray.new(RootPart.Position, -(RootPart.CFrame.UpVector * 100))
        local Hit, Position = workspace:FindPartOnRay(Raycast, Character)
        --
        if Hit and Position then
            return Ceil((RootPart.Position - Position).Magnitude)
        end
    end
    --
    function Atlanta:GetBoundingBox(BodyParts, RootPart)
        local Size = Vector3.new(0, 0, 0)
        --
        for Index, Value in pairs({"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}) do
            local Part = BodyParts[Value]
            local PartSize = (Part and Part.Size or Atlanta.Locals.PartSizes[Value])
            --
            if Value == "Head" then
                Size = (Size + Vector3.new(0, PartSize.Y, 0))
            elseif Value == "Torso" then
                Size = (Size + Vector3.new(PartSize.X, PartSize.Y, PartSize.Z))
            elseif Value == "Left Arm" then
                Size = (Size + Vector3.new(PartSize.X, 0, 0))
            elseif Value == "Right Arm" then
                Size = (Size + Vector3.new(PartSize.X, 0, 0))
            elseif Value == "Left Leg" then
                Size = (Size + Vector3.new(0, PartSize.Y, 0))
            elseif Value == "Right Leg" then
                Size = (Size + Vector3.new(0, PartSize.Y, 0))
            end
        end
        --
        return (RootPart.CFrame + Vector3.new(0, -0.125, 0)), Size
    end
    --
    function Atlanta:RayCast(Part, Origin, Ignore, Distance)
        local Ignore = Ignore or {}
        local Distance = Distance or 2000
        --
        local Cast = Ray.new(Origin, (Part.Position - Origin).Unit * Distance)
        local Hit = Workspace:FindPartOnRayWithIgnoreList(Cast, Ignore)
        --
        return (Hit and Hit:IsDescendantOf(Part.Parent)) == true, Hit
    end
    --
    function Atlanta:GetPlayers()
        return Players:GetPlayers()
    end
    --
    function Atlanta:Rejoin()
        Atlanta:TeleportPlace(game.PlaceId, game.JobId)
    end
    --
    do -- Game LUAs
        local Games = {
            [{8392422325}] = {Name = "Testing", Func = function()
                Atlanta.Safe = false
            end},
            [{6808416928, 6808489605}] = {Name = "Aimblox", Func = function()
                function Atlanta:GetTeam(Player)
                    return Player:GetAttribute("Team")
                end
            end},
            [{3233893879}] = {Name = "Bad Business", Func = function()
                local Modules
                --
                for Index, Value in pairs(getgc(false)) do
                    if typeof(Value) == "function" and islclosure(Value) and not is_synapse_function(Value) then
                        for Index, Value in pairs(getupvalues(Value)) do
                            if type(Value) == "table" and rawget(Value, "Kitty") then
                                Modules = getupvalue(getrawmetatable(Value).__index, 1);break
                            end
                        end
                    end
                end
                --
                function Movement:HandleHumanoid(Humanoid)
                end
                --
                function Atlanta:GetTeam(Player)
                    for Index, Team in pairs(Teams:GetChildren()) do
                        if Team.Players:FindFirstChild(Player.Name) then
                            return Team
                        end
                    end
                end
                --
                function Atlanta:GetCharacter(Player)
                    for Index, Object in pairs(Workspace:FindFirstChild("Characters"):GetChildren()) do
                        if Modules.Characters:GetPlayerFromCharacter(Object) == Player then
                            return Object
                        end
                    end
                    --return Modules.Characters:GetCharacter(Player)
                end
                --
                function Atlanta:GetHumanoid(Player, Character)
                    return "Humanoid"
                end
                --
                function Atlanta:GetHealth(Player, Character, Humanoid)
                    local Health = Character:FindFirstChild("Health")
                    local MaxHealth = (Health and Health:FindFirstChild("MaxHealth"))
                    --
                    if Health and MaxHealth then
                        return Health.Value, MaxHealth.Value
                    end
                end
                --
                function Atlanta:GetJumpPower(Player, Character, Humanoid)
                    return 16
                end
                --
                function Atlanta:GetRootPart(Player, Character, Humanoid)
                    return Character:FindFirstChild("Root")
                end
                --
                function Atlanta:ClientAlive(Player, Character, Humanoid)
                    local Health = Atlanta:GetHealth(Player, Character, Humanoid)
                    --
                    return Health ~= 0
                end
                --
                function Movement:HandleHumanoid(Humanoid)
                end
                --
                function Atlanta:GetCharacter(Player)
                    local Parts = Modules.Replication.getbodyparts(Player)
                    --
                    return (Parts and Parts.head and Parts.head.Parent)
                end
                --
                function Atlanta:GetHumanoid(Player, Character)
                    return "Humanoid"
                end
                --
                function Atlanta:GetHealth(Player, Character, Humanoid)
                    return Modules.Hud:getplayerhealth(Player)
                end
                --
                function Atlanta:GetJumpPower(Player, Character, Humanoid)
                    return 16
                end
                --
                function Atlanta:GetRootPart(Player, Character, Humanoid)
                    return Character:FindFirstChild("Torso")
                end
                --
                function Atlanta:ClientAlive(Player, Character, Humanoid)
                    return Modules.Hud:isplayeralive(Player)
                end
                --
                function Atlanta:GetIgnore(Unpacked)
                    if Unpacked then
                        return Workspace.CurrentCamera
                    else
                        return {Workspace.CurrentCamera}
                    end
                end
            end},
            [{5523314295}] = {Name = "Hellreaver", Func = function()
                function Atlanta:GetIgnore(Unpacked)
                    if Unpacked then
                        return Workspace.Rays
                    else
                        return {Workspace.Rays}
                    end
                end
            end},
            [{6075674379}] = {Name = "Emma", Func = function()
                function Atlanta:GetPlayers()
                    local Players = {}
                    --
                    for Index, Value in pairs(Workspace:GetChildren()) do
                        if Value and Value:IsA("Model") and Value.Name == "emma" then
                            local Object = Value
                            --
                            Players[#Players + 1] = {Character = Object, Parent = Workspace, UserId = "1000", Name = "emma", Team = "Bots"}
                        end
                    end
                    --
                    return Players
                end
                --
                Utility:Connection(Workspace.ChildAdded, function(Object)
                    if Object and Object:IsA("Model") and Object.Name == "emma" then
                        Atlanta:PlayerAdded({Character = Object, Parent = Workspace, UserId = "1000", Name = "emma", Team = "Bots"})
                    end
                end)
            end},
            [{2446927310}] = {Name = "Zombie Aim Challenge", Func = function()
                function Atlanta:GetPlayers()
                    local Players = {}
                    --
                    for Index, Value in pairs(Workspace.Bots:GetChildren()) do
                        if Value and Value:IsA("Model") and Value.Name == "Zombie" then
                            local Object = Value
                            --
                            Players[#Players + 1] = {Character = Object, Parent = Workspace.Bots, UserId = "1000", Name = "Zombie", Team = "Zombies"}
                        end
                    end
                    --
                    return Players
                end
                --
                function Atlanta:GetPlayerParent(Player)
                    return Player.Character and Player.Character.Parent
                end
                --
                Utility:Connection(Workspace.Bots.ChildAdded, function(Object)
                    if Object and Object:IsA("Model") and Object.Name == "Zombie" then
                        Atlanta:PlayerAdded({Character = Object, Parent = Workspace.Bots, UserId = "1000", Name = "Zombie", Team = "Zombies"})
                    end
                end)
            end},
            [{7352955828}] = {Name = "SC Zombie Aim Trainer", Func = function()
                function Atlanta:GetPlayers()
                    local Players = {}
                    --
                    for Index, Value in pairs(Workspace.Bots:GetChildren()) do
                        if Value and Value:IsA("Model") then
                            local Object = Value
                            --
                            Players[#Players + 1] = {Character = Object, Parent = Workspace.Bots, UserId = "1000", Name = "Bot" .. Index, Team = "Bots"}
                        end
                    end
                    --
                    return Players
                end
                --
                Utility:Connection(Workspace.Bots.ChildAdded, function(Object)
                    if Object and Object:IsA("Model") then
                        Atlanta:PlayerAdded({Character = Object, Parent = Workspace.Bots, UserId = "1000", Name = "Bot" .. Index, Team = "Bots"})
                    end
                end)
            end},
            [{7538200407}] = {Name = "RAC", Func = function()
                local HitParts = {"HitBox", "BigHitBox", "MiniHitBox"}
                --
                function Atlanta:GetRootPart(Player, Character, Humanoid)
                    return Find(HitParts, Character.Name) and Character:FindFirstChild("Part") or Humanoid.RootPart
                end
                --
                function Atlanta:GetPlayers()
                    local Players = {}
                    --
                    for Index, Value in pairs(Workspace.Game:FindFirstChild("nicetry2"):GetChildren()) do
                        if Value and Value:IsA("Model") then
                            local Object = Value
                            --
                            Players[#Players + 1] = {Character = Object, Parent = Value2, UserId = "1000", Name = "Bot" .. Index, Team = "Bots"}
                        end
                    end
                    --
                    for Index, Value in pairs(Workspace.Game.Scenarios:GetChildren()) do
                        for Index2, Value2 in pairs(Value:GetChildren()) do
                            if Find(HitParts, Value2.Name) and Value2:IsA("Model") then
                                local Object = Value2
                                --
                                Players[#Players + 1] = {Character = Object, Parent = Value2, UserId = "1000", Name = Value2.Name .. Index, Team = "Bots"}
                            end
                        end
                    end
                    --
                    return Players
                end
                --
                function Atlanta:GetBodyParts(Character, RootPart, Indexes, Hitboxes)
                    if Find(HitParts, Character.Name) then
                        return {[Indexes and "RootPart" or 1] = RootPart}
                    else
                        local Parts = {}
                        local Hitboxes = Hitboxes or {"Head", "Torso", "Arms", "Legs"}
                        --
                        for Index, Part in pairs(Character:GetChildren()) do
                            if Part:IsA("BasePart") and Part ~= RootPart then
                                if Find(Hitboxes, "Head") and Part.Name:lower():find("head") then
                                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                                elseif Find(Hitboxes, "Torso") and Part.Name:lower():find("torso") then
                                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                                elseif Find(Hitboxes, "Arms") and Part.Name:lower():find("arm") then
                                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                                elseif Find(Hitboxes, "Legs") and Part.Name:lower():find("leg") then
                                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                                elseif (Find(Hitboxes, "Arms") and Part.Name:lower():find("hand")) or (Find(Hitboxes, "Legs ") and Part.Name:lower():find("foot")) then
                                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                                end
                            end
                        end
                        --
                        return Parts
                    end
                end
                --
                function Atlanta:GetIgnore(Unpacked)
                    local Borders = {}
                    --
                    for Index, Value in pairs(Workspace.Game.Scenarios:GetChildren()) do
                        local Border = Value:FindFirstChild("Border")
                        --
                        if Value:IsA("Folder") and Border then
                            for Index2, Value2 in pairs(Border:GetChildren()) do
                                if Value2:IsA("BasePart") and Value2.Transparency == 1 then
                                    Borders[#Borders + 1] = Value2
                                end
                            end
                        end
                    end
                    --
                    if Unpacked then
                        return Unpack(Borders)
                    else
                        return Borders
                    end
                end
                --
                Utility:Connection(Workspace.Game:FindFirstChild("nicetry2").ChildAdded, function(Object)
                    if Object and Object:IsA("Model") then
                        Atlanta:PlayerAdded({Character = Object, Parent = Workspace.Bots, UserId = "1000", Name = "Bot" .. Index, Team = "Bots"})
                    end
                end)
            end}
        }
        --
        local PlaceId = game.PlaceId
        --
        for Index, Value in pairs(Games) do
            if Find(Index, PlaceId) then
                Utility:ThreadFunction(Value.Func, "Lx01")
            end
        end
    end
end
--
do -- Visuals
end
-- // UI Init
do -- UI
    local Window = Library:New({Name = ("InDay"), Style = 4, PageAmmount = 6, Size = Vector2.new(Atlanta.Language == "Lt" and 604 or 554, 629), Callback = function(Page)
        local PageName = Languages:GetTranslate(Page)
        --
        Atlanta.Locals.SelectedPage = PageName
        Atlanta.Locals.Window.VisualPreview:SetPreviewState(PageName == "Players")
    end})
    Library:UpdateColor("Accent", Color3.fromRGB(255, 255, 204))
    --
    Atlanta.Locals.Window = Window
    --
    Window.wminfo = (Languages:GetTranslation("[%s]  -  [Account = $ACC [$UID],  Build = $BUILD,  Ping = $PING,  FPS = $FPS]")):format("InDay"):gsub("$BUILD", "Developer"):gsub("$ACC", Atlanta.Account.Username):gsub("$UID", Atlanta.Account.UserID)
    Window.uibind = Enum.KeyCode.Z
    --
    local Rage = Window:Page({Name = Languages:GetTranslation("Rage")})
    local Misc = Window:Page({Name = Languages:GetTranslation("Anti Aim")})
    local Players2 = Window:Page({Name = Languages:GetTranslation("Players")})
    local Visuals2 = Window:Page({Name = Languages:GetTranslation("Visuals")})
    local Settings = Window:Page({Name = Languages:GetTranslation("Settings")})
    local Config = Window:Page({Name = Languages:GetTranslation("Configs")})
    --
    do -- // Content
        do -- Rage
        --[[
            local Rage_Lighting = Rage:Section({Name = Languages:GetTranslation("Lighting")})
            local Rage_Camera = Rage:Section({Name = Languages:GetTranslation("Extra"), Side = "Right"})
            local Rage_FOV, Visuals_Cursor = Visuals2:MultiSection({Sections = {Languages:GetTranslation("Field Of View"), Languages:GetTranslation("Cursor")}, Fill = true, Side = "Right"})
        ]]

            local Rage_Main = Rage:Section({Name = Languages:GetTranslation("Main"), Side = "Left"})
            local Rage_Extra = Rage:Section({Name = Languages:GetTranslation("Extra"), Fill = true, Side = "Left"})
            local Rage_Gui = Rage:Section({Name = Languages:GetTranslation("Gui"), Side = "Right"})
            local Rage_AutoBuy = Rage:Section({Name = Languages:GetTranslation("Auto Buys"), Fill = true, Side = "Right"})
            



local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Workspace = game:GetService("Workspace")

local REVOLVER_COST = 1421  -- Cost of the revolver
local teleportLocation = CFrame.new(999999999999999999, 999999999999999999, 999999999999999999) -- Target teleport coordinates

-- Function to announce notifications
local function announce(title, text, time)
    game.StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = time,
    })
end

-- Function to buy revolver and instantly teleport
local function buyRevolver()
    Character = Player.Character or Player.CharacterAdded:Wait()
    local RevolverShop = Workspace.Ignored.Shop["[Revolver] - $1421"]

    if Player.DataFolder.Currency.Value >= REVOLVER_COST then
        -- Teleport to the revolver shop
        Character.HumanoidRootPart.CFrame = RevolverShop.Head.CFrame

        -- Simulate clicking the purchase button
        local clickDetector = RevolverShop:FindFirstChild("ClickDetector")
        if clickDetector then
            fireclickdetector(clickDetector) -- Simulate clicking the detector
        end

        -- Instantly teleport to the specified location (-100, -100, -100)
        wait(0.1)
        Character.HumanoidRootPart.CFrame = teleportLocation
    else
        announce("Insufficient Funds", "You need more money to buy the revolver!", 3)
    end
end

-- Button to trigger revolver purchase
Rage_AutoBuy:Button({
    Name = "Buy Revolver",
    Callback = function()
        buyRevolver()
    end
})




local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

local REVOLVER_COST = 82  -- Cost of the revolver
local teleportLocation = CFrame.new(999999999999999999, 999999999999999999, 999999999999999999) -- Target teleport coordinates

-- Function to announce notifications
local function announce(title, text, time)
    game.StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = time,
    })
end

-- Function to buy revolver and instantly teleport
local function buyRevolver()
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RevolverShop = Workspace.Ignored.Shop["12 [Revolver Ammo] - $82"]

    if Player.DataFolder.Currency.Value >= REVOLVER_COST and Character and Character:FindFirstChild("HumanoidRootPart") then
        -- Teleport to the revolver shop
        Character.HumanoidRootPart.CFrame = RevolverShop.Head.CFrame

        -- Simulate clicking the purchase button multiple times to ensure it registers
        local clickDetector = RevolverShop:FindFirstChild("ClickDetector")
        if clickDetector then
            for i = 1, 10 do
                fireclickdetector(clickDetector)
                task.wait(0.1) -- Small delay between clicks
            end
        end

        -- Ensure teleport occurs instantly after purchase
        task.wait(0.1)
        if Character and Character:FindFirstChild("HumanoidRootPart") then
            Character.HumanoidRootPart.CFrame = teleportLocation
        end
    else
        announce("Insufficient Funds", "You need more money to buy the revolver!", 3)
    end
end

-- Ensure script runs even after death
Player.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
end)

-- Button to trigger revolver purchase
Rage_AutoBuy:Button({
    Name = "Buy Revolver ammo",
    Callback = function()
        task.spawn(buyRevolver) -- Ensures the function can be called multiple times without issue
    end
})








reloadCooldown = 0 -- Time in seconds to prevent spamming reloads
autoShootEnabled = false -- Toggle state
lastReloadTime = 0 -- Track the last reload time globally

function getPlayer()
    return game:GetService("Players").LocalPlayer
end

function getReplicatedStorage()
    return game:GetService("ReplicatedStorage")
end

function checkAmmoAndReload()
    if not autoShootEnabled then return end -- Exit if toggle is disabled

    local player = getPlayer()
    local character = player and player.Character
    if character then
        local tool = character:FindFirstChildWhichIsA("Tool")
        if tool then
            local ammo = tool:FindFirstChild("Ammo")
            if ammo and ammo.Value <= 0 then -- Check if ammo is 0 or less
                local currentTime = tick()
                if currentTime - lastReloadTime >= reloadCooldown then
                    -- Reload the gun
                    getReplicatedStorage().MainEvent:FireServer("Reload", tool)
                    lastReloadTime = currentTime -- Update the last reload time globally
                end
            end
        end
    end
end

function onHeartbeat()
    checkAmmoAndReload()
end

game:GetService("RunService").Heartbeat:Connect(onHeartbeat)

Rage_Extra:Toggle({
    Name = "Automatic Reload",
    Default = false,
    Pointer = "AutoShoot_Toggle",
    Callback = function(toggleState)
        autoShootEnabled = toggleState
        if toggleState then
            
        else
            
        end
    end
})

    Rage_Gui:Button({
    Name = "pastesense",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    loadstring(game:HttpGet("https://raw.githubusercontent.com/bebepro/pastesense/refs/heads/main/pastesense"))()
    end})

    Rage_Gui:Button({
    Name = "Anti v2",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    loadstring(game:HttpGet("https://raw.githubusercontent.com/flanchhh/AntiV2/refs/heads/main/Anti%20v2.lua"))();
    end})









--[[




isOrbiting, isEnabled, targetPlayer, teleportConnection, cameraFocus = false, false, nil, nil, nil
teleportInterval = 1
character, camera, player, Players = game:GetService("Players").LocalPlayer.Character, game.Workspace.CurrentCamera, game:GetService("Players").LocalPlayer, game:GetService("Players")
RunService = game:GetService("RunService")

local healthTriggered = {} -- Table to track health warning for each player
DefaultChatEvents = game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents

-- Function to check if the tool is in the player's backpack or inventory
function hasAUGTool()
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        if tool.Name == "[Rifle]" then
            return true
        end
    end
    for _, tool in ipairs(player.Character:GetChildren()) do
        if tool.Name == "[Rifle]" then
            return true
        end
    end
    return false
end

-- Function to buy the [Rifle] tool if not in inventory
function buyAUGTool()
    local augShop = game:GetService("Workspace").Ignored.Shop["[Rifle] - $1694"]  -- Update with your actual shop name
    local clickDetector = augShop:FindFirstChild("ClickDetector")
    
    if clickDetector then
        local originalPosition = character.HumanoidRootPart.CFrame -- Store the original position
        character.HumanoidRootPart.CFrame = augShop.Head.CFrame  -- Teleport to the [Rifle] shop

        -- Simulate clicks to buy the tool
        local endTime = tick() + 1  -- Try for 2 seconds
        while tick() < endTime do
            fireclickdetector(clickDetector) -- Simulate click
            task.wait(0)
        end

        -- After the purchase, teleport back to the original position
        character.HumanoidRootPart.CFrame = originalPosition

        -- Now equip the [Rifle] tool after purchasing
        equipAUGTool()
    end
end

-- Function to buy ammo for the [Rifle]
function buyRifleAmmo()
    local ammoShop = game:GetService("Workspace").Ignored.Shop"5 [Rifle Ammo] - $273"  -- Update with your actual ammo shop name
    local clickDetector = ammoShop:FindFirstChild("ClickDetector")
    
    if clickDetector then
        local originalPosition = character.HumanoidRootPart.CFrame -- Store the original position
        character.HumanoidRootPart.CFrame = ammoShop.Head.CFrame  -- Teleport to the ammo shop

        -- Unequip the [Rifle] tool before buying ammo
        local rifleTool = player.Backpack:FindFirstChild("[Rifle]")
        if rifleTool then
            player.Character.Humanoid:UnequipTools()
        end

        -- Simulate clicks to buy ammo 5 times
        for i = 1, 5 do
            local endTime = tick() + 1  -- Try for 2 seconds
            while tick() < endTime do
                fireclickdetector(clickDetector) -- Simulate click
                task.wait(0)
            end
        end

        -- After purchasing ammo, teleport back to the original position
        character.HumanoidRootPart.CFrame = originalPosition

        -- Equip the [Rifle] tool after purchasing ammo
        equipAUGTool()
    end
end

-- Function to equip the [Rifle] tool from the player's backpack
function equipAUGTool()
    -- Check if [Rifle] tool is in the backpack
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        if tool.Name == "[Rifle]" then
            -- Equip the tool
            player.Character.Humanoid:EquipTool(tool)
            return
        end
    end
end

-- Function to announce messages
function announce(title, text, time)
    game.StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = time,
    })
end

-- Main Functions
function startOrbitAroundTargetPlayer()
    if isOrbiting then return end

    -- Get the closest player to the mouse, but lock it in as the target for future orbit
    local closestPlayer = getClosestPlayerToMouse()
    if closestPlayer then
        targetPlayer = closestPlayer
    end

    if not targetPlayer then return end -- Ensure there's a valid target player

    isOrbiting = true
    cameraFocus = camera.CameraSubject
    camera.CameraSubject = targetPlayer.Character.HumanoidRootPart  -- Focus camera on target player

    local angle = 0
    teleportConnection = RunService.RenderStepped:Connect(function()
        if isOrbiting and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
            local targetHeight = targetPosition.Y -- Fix height to target player's height

            -- Random adjustments for orbit effect (only on X and Z, Y remains the same)
            local randomDirection = Vector3.new(
                math.random(-10, 10),  -- Random horizontal movement
                0,                     -- Keep the Y height fixed
                math.random(-10, 10)   -- Random depth movement
            )

            -- Calculate new teleport position around the closest player
            local newPosition = Vector3.new(targetPosition.X + randomDirection.X, targetHeight, targetPosition.Z + randomDirection.Z)

            -- Teleport the player to the new position
            if character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.CFrame = CFrame.new(newPosition)
            end

            -- Check if target's health is below 5, and send the messages
            local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health < 5 then
                -- Check if health trigger has already been activated
                if not healthTriggered[targetPlayer.UserId] then
                    -- Send the first message
                    sendMessage("Anti trashmode services")

                    -- Set a delay (Cooldown) to prevent repeated messages too soon
                    healthTriggered[targetPlayer.UserId] = true

                    -- Wait for 0.1 seconds before sending the second message
                    task.wait(0.1)

                    -- Send second message
                    sendMessage("undetek!!!!1!!")

                    -- Set a cooldown (delay) to reset healthTriggered after a certain time
                    task.delay(5, function() 
                        healthTriggered[targetPlayer.UserId] = nil
                    end)
                end
            end

            -- Check if the [Rifle] tool has 0 ammo for more than 4 seconds
            local rifleTool = player.Backpack:FindFirstChild("[Rifle]")
            if rifleTool and rifleTool:IsA("Tool") and rifleTool:FindFirstChild("Ammo") then
                local ammoValue = rifleTool.Ammo.Value
                if ammoValue == 0 then
                    -- Wait for 4 seconds to confirm if ammo stays at 0
                    task.wait(4)
                    -- Check again if ammo is still 0
                    if rifleTool.Ammo.Value == 0 then
                        -- If ammo is still 0, stop orbiting, buy ammo, and then resume
                        stopOrbiting()
                        buyRifleAmmo()  -- Buy ammo
                        task.wait(1)  -- Wait for the ammo purchase to complete
                        startOrbitAroundTargetPlayer()  -- Resume orbiting after buying ammo
                    end
                end
            end
        end
    end)
end

function stopOrbiting()
    if isOrbiting then
        isOrbiting = false

        if teleportConnection then
            teleportConnection:Disconnect()
            teleportConnection = nil
        end

        -- Revert camera to original focus (your character)
        if cameraFocus then
            camera.CameraSubject = cameraFocus
        end
    end
end

-- Get closest player to the mouse
function getClosestPlayerToMouse()
    local mouse = player:GetMouse()
    local closestPlayer, closestDistance = nil, math.huge

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local screenPosition, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)

            if onScreen then
                local distance = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenPosition.X, screenPosition.Y)).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = otherPlayer
                end
            end
        end
    end

    return closestPlayer
end

-- Reset Everything on Respawn or Death
function onCharacterAdded(newCharacter)
    character = newCharacter
    isOrbiting = false

    if teleportConnection then
        teleportConnection:Disconnect()
        teleportConnection = nil
    end
end

function onPlayerDeath()
    stopOrbiting()
end

-- Player Respawn and Death Monitoring
player.CharacterAdded:Connect(onCharacterAdded)

if character:FindFirstChild("Humanoid") then
    character.Humanoid.Died:Connect(onPlayerDeath)
end

-- User Interface Callbacks
Rage_Main:Toggle({
    Name = "hvh",
    Default = false,
    Pointer = "Orbit_Toggle",
    Callback = function(state)
        isEnabled = state
        if not isEnabled then
            stopOrbiting()
        else
            -- Check if you have the [Rifle] tool before enabling the teleportation
            if not hasAUGTool() then
                -- Cancel random teleport and buy [Rifle] tool
                stopOrbiting()
                buyAUGTool()  -- Teleport to buy the [Rifle] tool
                task.wait(0)  -- Lower delay after buying the tool
                -- After buying, restart random teleport
                startOrbitAroundTargetPlayer()
            else
                -- If [Rifle] is owned, start random teleport
                equipAUGTool()  -- Ensure rifle is equipped
                startOrbitAroundTargetPlayer()
            end
        end
    end
}):Keybind({
    Default = Enum.KeyCode.Q,
    KeybindName = "Toggle Orbiting",
    Mode = "Toggle",
    Pointer = "Orbit_Bind",
    Callback = function()
        if isEnabled then
        equipAUGTool()
            if isOrbiting then
                stopOrbiting()
            else
                startOrbitAroundTargetPlayer()
                equipAUGTool()
            end
        end
    end
})

Rage_Main:Toggle({
    Name = "Toggle Camera Focus on Player",
    Default = true,  -- Start with camera focused on player
    Pointer = "Camera_Focus_Toggle",
    Callback = function(state)
        if state then
            -- Camera focus on targetPlayer if orbiting
            if isOrbiting and targetPlayer then
                camera.CameraSubject = targetPlayer.Character.HumanoidRootPart
            end
        else
            -- Revert back to default camera subject (your character)
            if character:FindFirstChild("HumanoidRootPart") then
                camera.CameraSubject = character.HumanoidRootPart
            end
        end
    end
})

]]

--[[ 
1234
isOrbiting, isEnabled, targetPlayer, teleportConnection, cameraFocus = false, false, nil, nil, nil
teleportInterval = 1
character, camera, player, Players = game:GetService("Players").LocalPlayer.Character, game.Workspace.CurrentCamera, game:GetService("Players").LocalPlayer, game:GetService("Players")
RunService = game:GetService("RunService")

-- Existing healthTriggered table
local healthTriggered = {}

-- Function to check if the tool is in the player's backpack or inventory
function hasAUGTool()
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        if tool.Name == "[Rifle]" then
            return true
        end
    end
    for _, tool in ipairs(player.Character:GetChildren()) do
        if tool.Name == "[Rifle]" then
            return true
        end
    end
    return false
end

-- Function to buy the [Rifle] tool if not in inventory
function buyAUGTool()
    local augShop = game:GetService("Workspace").Ignored.Shop["[Rifle] - $1694"]  -- Update with your actual shop name
    local clickDetector = augShop:FindFirstChild("ClickDetector")
    
    if clickDetector then
        local originalPosition = character.HumanoidRootPart.CFrame -- Store the original position
        character.HumanoidRootPart.CFrame = augShop.Head.CFrame  -- Teleport to the [Rifle] shop

        -- Simulate clicks to buy the tool
        local endTime = tick() + 1  -- Try for 2 seconds
        while tick() < endTime do
            fireclickdetector(clickDetector) -- Simulate click
            task.wait(0)
        end

        -- After the purchase, teleport back to the original position
        character.HumanoidRootPart.CFrame = originalPosition
        -- Equip the [Rifle] tool after purchasing
        equipAUGTool()
    end
end

-- Function to equip the [Rifle] tool from the player's backpack
function equipAUGTool()
    -- Check if [Rifle] tool is in the backpack
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        if tool.Name == "[Rifle]" then
            -- Equip the tool
            player.Character.Humanoid:EquipTool(tool)
            announce("Tool Equipped", "[Rifle] has been equipped!", 3)
            return
        end
    end
end

-- Function to announce messages
function announce(title, text, time)
    game.StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = time,
    })
end

-- Check for health below 5 and send messages
local function checkHealth()
    local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    if humanoid and humanoid.Health < 5 and not healthTriggered[targetPlayer.UserId] then
        -- Send first message
        sendMessage("Anti trashmode services")

        -- Set a delay (Cooldown) to prevent repeated messages too soon
        healthTriggered[targetPlayer.UserId] = true

        -- Wait for 0.1 seconds before sending the second message
        task.wait(0.1)
        -- Send second message
        sendMessage("undetek!!!!1!!")

        -- Set a cooldown (delay) to reset healthTriggered after a certain time
        task.delay(5, function() 
            healthTriggered[targetPlayer.UserId] = nil
        end)
    end
end

-- Main Functions
function startOrbitAroundTargetPlayer()
    if isOrbiting then return end

    -- Get the closest player to the mouse, but lock it in as the target for future orbit
    local closestPlayer = getClosestPlayerToMouse()
    if closestPlayer then
        targetPlayer = closestPlayer
    end

    if not targetPlayer then return end -- Ensure there's a valid target player

    isOrbiting = true
    cameraFocus = camera.CameraSubject
    camera.CameraSubject = targetPlayer.Character.HumanoidRootPart  -- Focus camera on target player

    local angle = 0
    teleportConnection = RunService.RenderStepped:Connect(function()
        if isOrbiting and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
            local targetHeight = targetPosition.Y -- Fix height to target player's height

            -- Random adjustments for orbit effect (only on X and Z, Y remains the same)
            local randomDirection = Vector3.new(
                math.random(-10, 10),  -- Random horizontal movement
                0,                     -- Keep the Y height fixed
                math.random(-10, 10)   -- Random depth movement
            )

            -- Calculate new teleport position around the closest player
            local newPosition = Vector3.new(targetPosition.X + randomDirection.X, targetHeight, targetPosition.Z + randomDirection.Z)

            -- Teleport the player to the new position
            if character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.CFrame = CFrame.new(newPosition)
            end
        end

        -- Check health while orbiting
        checkHealth()
    end)
end

function stopOrbiting()
    if isOrbiting then
        isOrbiting = false

        if teleportConnection then
            teleportConnection:Disconnect()
            teleportConnection = nil
        end

        -- Revert camera to original focus (your character)
        if cameraFocus then
            camera.CameraSubject = cameraFocus
        end
    end
end

-- Get closest player to the mouse
function getClosestPlayerToMouse()
    local mouse = player:GetMouse()
    local closestPlayer, closestDistance = nil, math.huge

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local screenPosition, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)

            if onScreen then
                local distance = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenPosition.X, screenPosition.Y)).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = otherPlayer
                end
            end
        end
    end

    return closestPlayer
end

-- Reset Everything on Respawn or Death
function onCharacterAdded(newCharacter)
    character = newCharacter
    isOrbiting = false

    if teleportConnection then
        teleportConnection:Disconnect()
        teleportConnection = nil
    end
end

function onPlayerDeath()
    stopOrbiting()
end

-- Player Respawn and Death Monitoring
player.CharacterAdded:Connect(onCharacterAdded)

if character:FindFirstChild("Humanoid") then
    character.Humanoid.Died:Connect(onPlayerDeath)
end

-- User Interface Callbacks
Rage_Main:Toggle({
    Name = "hvh",
    Default = false,
    Pointer = "Orbit_Toggle",
    Callback = function(state)
        isEnabled = state
        if not isEnabled then
            stopOrbiting()
        else
            -- Check if you have the [Rifle] tool before enabling the teleportation
            if not hasAUGTool() then
                announce("Tool Check", "[Rifle] tool missing. Teleporting to buy it.", 3)
                -- Cancel random teleport and buy [Rifle] tool
                stopOrbiting()
                buyAUGTool()  -- Teleport to buy the [Rifle] tool
                task.wait(0)  -- Lower delay after buying the tool
                -- After buying, restart random teleport
                startOrbitAroundTargetPlayer()
            else
                -- If [Rifle] is owned, start random teleport
                equipAUGTool()  -- Ensure rifle is equipped
                startOrbitAroundTargetPlayer()
            end
        end
    end
}):Keybind({
    Default = Enum.KeyCode.Q,
    KeybindName = "Toggle Orbiting",
    Mode = "Toggle",
    Pointer = "Orbit_Bind",
    Callback = function()
        if isEnabled then
            if isOrbiting then
                stopOrbiting()  -- Stop orbiting if already orbiting
            else
                -- If you don't have the rifle, buy and equip it
                if not hasAUGTool() then
                    announce("Tool Check", "[Rifle] tool missing. Buying and equipping now.", 3)
                    buyAUGTool()  -- Teleport to buy the [Rifle] tool
                    task.wait(0)  -- Lower delay after buying the tool
                else
                    -- If you already have the rifle, just equip it
                    equipAUGTool()
                end
                -- Start orbiting the target
                startOrbitAroundTargetPlayer()
            end
        end
    end
})

Rage_Main:Toggle({
    Name = "Toggle Camera Focus on Player",
    Default = true,  -- Start with camera focused on player
    Pointer = "Camera_Focus_Toggle",
    Callback = function(state)
        if state then
            -- Camera focus on targetPlayer if orbiting
            if isOrbiting and targetPlayer then
                camera.CameraSubject = targetPlayer.Character.HumanoidRootPart
            end
        else
            -- Revert back to default camera subject (your character)
            if character:FindFirstChild("HumanoidRootPart") then
                camera.CameraSubject = character.HumanoidRootPart
            end
        end
    end
})





]]


isOrbiting, isEnabled, targetPlayer, teleportConnection, cameraFocus = false, false, nil, nil, nil
teleportInterval = 1
predictionEnabled, predictionFactor, teleportHeight, randomFactor = false, 0.5, 5, 10  -- Added randomFactor
character, camera, player, Players = game:GetService("Players").LocalPlayer.Character, game.Workspace.CurrentCamera, game:GetService("Players").LocalPlayer, game:GetService("Players")
RunService = game:GetService("RunService")

-- Existing healthTriggered table
local healthTriggered = {}

-- Function to check if the tool is in the player's backpack or inventory
function hasAUGTool()
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        if tool.Name == "[Rifle]" then
            return true
        end
    end
    for _, tool in ipairs(player.Character:GetChildren()) do
        if tool.Name == "[Rifle]" then
            return true
        end
    end
    return false
end

-- Function to buy the [Rifle] tool if not in inventory
function buyAUGTool()
    local augShop = game:GetService("Workspace").Ignored.Shop["[Rifle] - $1694"] -- Update with your actual shop name
    local clickDetector = augShop:FindFirstChild("ClickDetector")
    
    if clickDetector then
        local originalPosition = character.HumanoidRootPart.CFrame -- Store the original position
        character.HumanoidRootPart.CFrame = augShop.Head.CFrame -- Teleport to the [Rifle] shop

        -- Simulate clicks to buy the tool
        local endTime = tick() + 1 -- Try for 2 seconds
        while tick() < endTime do
            fireclickdetector(clickDetector) -- Simulate click
            task.wait(0)
        end

        -- After the purchase, teleport back to the original position
        character.HumanoidRootPart.CFrame = originalPosition
        announce("Purchase", "[Rifle] tool bought successfully.", 3)

        -- Equip the [Rifle] tool after purchasing
        equipAUGTool()
    end
end

-- Function to equip the [Rifle] tool from the player's backpack
function equipAUGTool()
    -- Check if [Rifle] tool is in the backpack
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        if tool.Name == "[Rifle]" then
            -- Equip the tool
            player.Character.Humanoid:EquipTool(tool)
            announce("Tool Equipped", "[Rifle] has been equipped!", 3)
            return
        end
    end
end

-- Function to announce messages
function announce(title, text, time)
    game.StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = time,
    })
end

-- Check for health below 5 and send messages
local function checkHealth()
    local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    if humanoid and humanoid.Health < 5 and not healthTriggered[targetPlayer.UserId] then
        -- Send first message
        sendMessage("Anti trashmode services")

        -- Set a delay (Cooldown) to prevent repeated messages too soon
        healthTriggered[targetPlayer.UserId] = true

        -- Wait for 0.1 seconds before sending the second message
        task.wait(0.1)
        -- Send second message
        sendMessage("no comp")

        -- Set a cooldown (delay) to reset healthTriggered after a certain time
        task.delay(5, function() 
            healthTriggered[targetPlayer.UserId] = nil
        end)
    end
end

-- Function to predict target's future position
function getPredictedPosition(targetCharacter)
    if not predictionEnabled then
        return targetCharacter.HumanoidRootPart.Position
    end

    local rootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if rootPart and rootPart.Velocity then
        return rootPart.Position + rootPart.Velocity * predictionFactor
    else
        return rootPart.Position
    end
end

function startOrbitAroundTargetPlayer()
    if isOrbiting then return end

    -- Get the closest player to the mouse, but lock it in as the target for future orbit
    local closestPlayer = getClosestPlayerToMouse()
    if closestPlayer then
        targetPlayer = closestPlayer
    end

    if not targetPlayer then return end -- Ensure there's a valid target player

    isOrbiting = true
    cameraFocus = camera.CameraSubject
    camera.CameraSubject = targetPlayer.Character.HumanoidRootPart -- Focus camera on target player

    local angle = 0
    teleportConnection = RunService.RenderStepped:Connect(function()
        if isOrbiting and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = getPredictedPosition(targetPlayer.Character)
            local targetHeight = targetPosition.Y + teleportHeight -- Adjust height based on slider

            -- Random adjustments for orbit effect (only on X and Z, Y remains the same)
            local randomDirection = Vector3.new(
                math.random(-randomFactor, randomFactor), -- Random horizontal movement
                0, -- Keep the Y height fixed
                math.random(-randomFactor, randomFactor) -- Random depth movement
            )

            -- Calculate new teleport position around the predicted position
            local newPosition = Vector3.new(targetPosition.X + randomDirection.X, targetHeight, targetPosition.Z + randomDirection.Z)

            -- Teleport the player to the new position
            if character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.CFrame = CFrame.new(newPosition)
            end
        end

        -- Check health while orbiting
        checkHealth()
    end)

    -- Start the ammo-buying loop
    startAmmoLoop()
end


function stopOrbiting()
    if isOrbiting then
        isOrbiting = false

        if teleportConnection then
            teleportConnection:Disconnect()
            teleportConnection = nil
        end

        -- Revert camera to original focus (your character)
        if cameraFocus then
            camera.CameraSubject = cameraFocus
        end

        -- Single teleport to the target for 1 second
        local stopTime = tick() + 1
        while tick() < stopTime do
            teleportToTarget()
            task.wait(0.4)
        end
    end
end

-- Single teleport to the target
function teleportToTarget()
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetPosition = getPredictedPosition(targetPlayer.Character)
        -- Teleport directly to the predicted position without any offset
        character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
    end
end


-- Get closest player to the mouse
function getClosestPlayerToMouse()
    local mouse = player:GetMouse()
    local closestPlayer, closestDistance = nil, math.huge

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local screenPosition, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)

            if onScreen then
                local distance = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenPosition.X, screenPosition.Y)).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = otherPlayer
                end
            end
        end
    end

    return closestPlayer
end

function onCharacterAdded(newCharacter)
    -- Set the new character
    character = newCharacter
    task.wait(0.5) -- Allow the new character to load

    -- Ensure camera refocuses on the target player (after respawn)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        camera.CameraSubject = targetPlayer.Character.HumanoidRootPart
    else
        -- If no target player or target player is invalid, focus back on the local character
        camera.CameraSubject = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Humanoid")
    end

    -- If orbiting is enabled, restart the orbiting behavior after respawn
    if isEnabled and targetPlayer then
        task.wait(0.5) -- Allow full load before starting orbit
        startOrbitAroundTargetPlayer()
    end
end


function stopOrbiting()
    if isOrbiting then
        isOrbiting = false

        if teleportConnection then
            teleportConnection:Disconnect()
            teleportConnection = nil
        end

        -- Ensure camera focus returns to the player's character when orbiting is stopped
        if cameraFocus then
            camera.CameraSubject = cameraFocus
        else
            -- If cameraFocus isn't set (e.g., no previous orbit), focus on the local playerâ€™s character
            camera.CameraSubject = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Humanoid")
        end
    end
end




-- User Interface Callbacks
Rage_Main:Toggle({
    Name = "Enabled",
    Default = false,
    Pointer = "Orbit_Toggle",
    Callback = function(state)
        isEnabled = state
        if not isEnabled then
            stopOrbiting()
        else
            -- Check if you have the [Rifle] tool before enabling the teleportation
            if not hasAUGTool() then
                announce("Tool Check", "[Rifle] tool missing. Teleporting to buy it.", 3)
                stopOrbiting()
                buyAUGTool()
                task.wait(0)
                startOrbitAroundTargetPlayer()
            else
                equipAUGTool()
                startOrbitAroundTargetPlayer()
            end
        end
    end
}):Keybind({
    Default = Enum.KeyCode.Q,
    KeybindName = "Toggle Orbiting",
    Mode = "Toggle",
    Pointer = "Orbit_Bind",
    Callback = function()
        if isEnabled then
            if isOrbiting then
                stopOrbiting()
            else
                if not hasAUGTool() then
                    announce("Tool Check", "[Rifle] tool missing. Buying and equipping now.", 3)
                    buyAUGTool()
                    task.wait(0)
                else
                    equipAUGTool()
                end
                startOrbitAroundTargetPlayer()
            end
        end
    end
})


Rage_Main:Toggle({
    Name = "Predict velocity",
    Default = false,
    Pointer = "Prediction_Toggle",
    Callback = function(state)
        predictionEnabled = state
    end
})


Rage_Main:Slider({
    Name = "Prediction amount",
    Minimum = 0,
    Maximum = 10,
    Default = 0.5,
    Decimals = 0.1,
    Pointer = "PredictionFactor_Slider",
    Callback = function(value)
        predictionFactor = value
    end
})

Rage_Main:Slider({
    Name = "Teleport height",
    Minimum = -40,
    Maximum = 40,
    Default = 5,
    Decimals = 1,
    Pointer = "TeleportHeight_Slider",
    Callback = function(value)
        teleportHeight = value
    end
})

Rage_Main:Slider({
    Name = "Random Teleport distance",
    Minimum = 0,
    Maximum = 200,
    Default = 10,
    Decimals = 1,
    Pointer = "RandomFactor_Slider",
    Callback = function(value)
        randomFactor = value
    end
})



local Players = game:GetService("Players")
local Client = Players.LocalPlayer
local autoResetEnabled = false

-- Function to monitor player's K.O state
local function startMonitoring(state)
    task.spawn(function()
        while state and task.wait(0) do
            if Client.Character and Client.Character:FindFirstChild("BodyEffects") then
                local BodyEffects = Client.Character:WaitForChild("BodyEffects")

                if BodyEffects["K.O"].Value == true then
                    local humanoid = Client.Character:FindFirstChild("Humanoid")
                    if humanoid then
                        humanoid.Health = 0
                    end
                end
            end
        end
    end)
end

-- Toggle function
Rage_Extra:Toggle({
    Name = "Anti Stomp",
    Default = false,
    Pointer = "AntiStomp_Enabled",
    Callback = function(state)
        autoResetEnabled = state -- Update toggle state

        if state then
            startMonitoring(true)
        end
    end,
})






    Rage_Gui:Button({
    Name = "Buy rifle & ammo",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
local character = player.Character or player.CharacterAdded:Wait()

-- Rifle shop
local augShop = game:GetService("Workspace").Ignored.Shop["[Rifle] - $1694"]
local rifleClickDetector = augShop and augShop:FindFirstChild("ClickDetector")

-- Ammo shop
local ammoShop = game:GetService("Workspace").Ignored.Shop["5 [Rifle Ammo] - $273"]
local ammoClickDetector = ammoShop and ammoShop:FindFirstChild("ClickDetector")

-- Purchase attempts
local riflebuytimes = 2
local ammobuytimes = 7

-- Function to check if the player has a specific tool
local function hasTool(toolName)
    -- Check the backpack
    for _, tool in ipairs(player.Backpack:GetChildren()) do
        if tool.Name == toolName then
            return true
        end
    end
    -- Check the character (equipped items)
    local characterTools = character:FindFirstChildOfClass("Tool")
    if characterTools and characterTools.Name == toolName then
        return true
    end
    return false
end

-- Function to buy item
local function buyItem(shop, clickDetector, numClicks)
    if not shop or not clickDetector then return end
    local originalPosition = character.HumanoidRootPart.CFrame -- Store the original position
    character.HumanoidRootPart.CFrame = shop.Head.CFrame -- Teleport to the shop

    -- Simulate multiple clicks to buy the item
    for i = 1, numClicks do
        fireclickdetector(clickDetector) -- Simulate click
        task.wait(0) -- Slight delay between clicks to make sure it registers
    end
end

-- Check if the player already has the rifle
if not hasTool("[Rifle]") then
    -- Attempt to buy the rifle up to riflebuytimes
    for i = 1, riflebuytimes do
        buyItem(augShop, rifleClickDetector, 3) -- 3 click attempts per purchase
        task.wait(0.6) -- Small delay between attempts
        if hasTool("[Rifle]") then break end -- Stop if rifle was successfully bought
    end
end

-- Wait a small amount of time before buying ammo
task.wait(0.6)

-- Buy ammo multiple times
if ammoClickDetector then
    for i = 1, ammobuytimes do
        buyItem(ammoShop, ammoClickDetector, 1) -- 1 click per ammo purchase attempt
        task.wait(0.4) -- Delay between ammo purchases
    end
end
    end})





        end
        --
        do -- Players
            local Players_Main = Players2:Section({Name = Languages:GetTranslation("Main"), Fill = true})
            local Players_Extra = Players2:Section({Name = Languages:GetTranslation("Extra"), Side = "Right"})











    Players_Extra:Button({
    Name = "Force Reset",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    game.Players.LocalPlayer.Character.Humanoid.Health = 0
    end})




    Players_Extra:Button({
    Name = "Anti Sit",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    for i, v in pairs(Workspace:GetDescendants()) do
    if v:IsA("Seat") then
        v:Destroy()  -- Destroy the seat to prevent players from sitting
    end
end
    end})



    Players_Extra:Button({
    Name = "Anti Void",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
        -- Adjust the FallenPartsDestroyHeight for parts to fall into the void at a much lower level
Workspace.FallenPartsDestroyHeight = -5000000000000  -- You can change this to your desired height for parts

game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        local Humanoid = character:WaitForChild("Humanoid")

        -- Listen for when the player is falling
        Humanoid.FreeFalling:Connect(function()
            -- Check if the player's Y position is below the void threshold (e.g., -500)
            if character.HumanoidRootPart.Position.Y < -500 then
                -- Prevent the player from dying by maintaining their health
                Humanoid.Health = Humanoid.Health  -- Keeps health from decreasing
            end
        end)
    end)
end)
    end})







    Players_Extra:Button({
    Name = "Chat Spy",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    -- Global function to get the local player
function getPlayer()
    return game:GetService("Players").LocalPlayer
end

-- Global function to get the chat GUI
function getChat()
    return getPlayer().PlayerGui:WaitForChild("Chat")
end

-- Global function to toggle chat visibility
function toggleChatVisibility()
    local chatFrame = getChat().Frame
    chatFrame.ChatChannelParentFrame.Visible = true
    chatFrame.ChatBarParentFrame.Position = chatFrame.ChatChannelParentFrame.Position + UDim2.new(UDim.new(), chatFrame.ChatChannelParentFrame.Size.Y)
end

-- Global function to handle chatting logic
function onChatted(p, msg, saymsg, getmsg)
    if _G.chatSpyInstance == instance then
        if p == getPlayer() and msg:lower():sub(1, 4) == "/spy" then
            enabled = not enabled
            wait(0.3)
            privateProperties.Text = "{SPY "..(enabled and "EN" or "DIS").."ABLED}"
            game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", privateProperties)
        elseif enabled and (spyOnMyself == true or p ~= getPlayer()) then
            msg = msg:gsub("[\n\r]", ''):gsub("\t", ' '):gsub("[ ]+", ' ')
            local hidden = true
            local conn = getmsg.OnClientEvent:Connect(function(packet, channel)
                if packet.SpeakerUserId == p.UserId and packet.Message == msg:sub(#msg - #packet.Message + 1) and (channel == "All" or (channel == "Team" and public == false and game:GetService("Players")[packet.FromSpeaker].Team == getPlayer().Team)) then
                    hidden = false
                end
            end)
            wait(1)
            conn:Disconnect()
            if hidden and enabled then
                if public then
                    saymsg:FireServer((publicItalics and "/me " or '').."{SPY} [".. p.Name .."]: "..msg, "All")
                else
                    privateProperties.Text = "{SPY} [".. p.Name .."]: "..msg
                    game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", privateProperties)
                end
            end
        end
    end
end

-- Global function to initialize the chat spy system
function initializeChatSpy()
    local saymsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
    local getmsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("OnMessageDoneFiltering")
    local instance = (_G.chatSpyInstance or 0) + 1
    _G.chatSpyInstance = instance

    -- Setup the chat visibility
    toggleChatVisibility()

    -- Listen for all players' messages
    for _, p in ipairs(game:GetService("Players"):GetPlayers()) do
        p.Chatted:Connect(function(msg) onChatted(p, msg, saymsg, getmsg) end)
    end

    -- Listen for new players joining the game
    game:GetService("Players").PlayerAdded:Connect(function(p)
        p.Chatted:Connect(function(msg) onChatted(p, msg, saymsg, getmsg) end)
    end)

    -- Initial system message showing Spy status
    privateProperties.Text = "{SPY "..(enabled and "EN" or "DIS").."ABLED}"
    game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", privateProperties)
end

-- Initialize chat spy system
initializeChatSpy()

    end})






    Players_Extra:Button({
    Name = "get money",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    function redeemCode(code)
    local args = {
        [1] = "EnterPromoCode",
        [2] = code
    }

    game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer(unpack(args))
end

-- Redeem multiple codes with a delay
redeemCode("pumpkins2023")
print("1")
wait(6)
redeemCode("DAUP")
print("2")
wait(6)
redeemCode("TRADEME!")
print("3")
wait(6)
redeemCode("HALLOWEEN2024")
print("4")
wait(6)
redeemCode("DACARNIVAL")
print("5")
wait(6)
redeemCode("VIP")
print("6")
wait(6)
redeemCode("SHRIMP")
print("7")
wait(6)
redeemCode("2025")
print("8")
wait(6)
redeemCode("ShortCake")
print("9")
wait(6)
redeemCode("RUBY")
print("10")
wait(6)
redeemCode("Beary")
print("11")
wait(6)
redeemCode("THANKSGIVING24")
print("12")
    end})



    Players_Extra:Button({
    Name = "Animation",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    local Animate = game.Players.LocalPlayer.Character.Animate
    --[[ Animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=616158929"
    Animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=616160636"
    ]]
    Animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=616168032"
    Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
    Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=5319841935"
    Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=5319839762"
    game.Players.LocalPlayer.Character.Humanoid.Jump = false
    end})



    Players_Extra:Button({
    Name = "Animation v2",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    local Animate = game.Players.LocalPlayer.Character.Animate
    Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=616161997"
    Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=616157476"
    game.Players.LocalPlayer.Character.Humanoid.Jump = false
    end})



    Players_Extra:Button({
    Name = "Animation v3",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    local Animate = game.Players.LocalPlayer.Character.Animate
    Animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=616168032"
    Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
    Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=656117878"
    Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
    game.Players.LocalPlayer.Character.Humanoid.Jump = false
    end})


    Players_Extra:Button({
    Name = "Animation v4",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    local Animate = game.Players.LocalPlayer.Character.Animate
    Animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=707742142"
    Animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=707855907"
    Animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=707897309"
    Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=707861613"
    game.Players.LocalPlayer.Character.Humanoid.Jump = false
    end})



    Players_Extra:Button({
    Name = "Headless & Korblox",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    _G.Character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
_G.Head = _G.Character:WaitForChild("Head")

-- Make the head invisible
_G.Head.Transparency = 1

-- Optional: Remove the face decal
_G.Face = _G.Head:FindFirstChild("face")
if _G.Face then _G.Face:Destroy() end

-- Wait for the character to load
_G.Character:WaitForChild("Humanoid")

-- Replace the right leg with a Korblox leg
function ReplaceRightLeg()
    _G.RightUpperLeg = _G.Character:FindFirstChild("RightUpperLeg")
    _G.RightLowerLeg = _G.Character:FindFirstChild("RightLowerLeg")
    
    if _G.RightLowerLeg then
        _G.RightUpperLeg.Transparency = 1
        _G.RightLowerLeg:Destroy()
    end

    -- Create and configure the new Korblox leg
    _G.NewLeg = Instance.new("Part")
    _G.NewLeg.Name, _G.NewLeg.Size, _G.NewLeg.Parent = "KorbloxLeg", Vector3.new(1, 3, 1), _G.Character
    _G.NewLeg.Anchored, _G.NewLeg.CanCollide, _G.NewLeg.Position = false, false, _G.RightUpperLeg.Position

    _G.Mesh = Instance.new("SpecialMesh", _G.NewLeg)
    _G.Mesh.MeshId, _G.Mesh.TextureId, _G.Mesh.Scale = "http://www.roblox.com/asset/?id=902942093", "http://www.roblox.com/asset/?id=902843398", Vector3.new(1, 1.1, 1)

    _G.Weld = Instance.new("Motor6D")
    _G.Weld.Part0, _G.Weld.Part1, _G.Weld.C0, _G.Weld.Parent = _G.RightUpperLeg, _G.NewLeg, CFrame.new(0, 0.2, 0), _G.RightUpperLeg
end

ReplaceRightLeg()

    end})




local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Workspace = game:GetService("Workspace")

local PERCENT_TO_BUY_ARMOR = 30 -- Percent of armor left that you want to buy
local ArmorCost = 2513         -- Updated cost of the armor
local buyingActive = false     -- Initial state (disabled)

-- Function to announce notifications
local function announce(title, text, time)
    game.StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = time,
    })
end

-- Function to handle buying armor
local function buyArmor()
    while buyingActive do
        -- Ensure the player's character exists and has a HumanoidRootPart
        Character = Player.Character or Player.CharacterAdded:Wait()
        local Armor = Character:FindFirstChild("BodyEffects") and Character.BodyEffects:FindFirstChild("Armor")
        local ArmorShop = Workspace.Ignored.Shop["[High-Medium Armor] - $2513"]

        if Armor and Armor.Value <= PERCENT_TO_BUY_ARMOR and Player.DataFolder.Currency.Value >= ArmorCost then
            local originalPosition = Character.HumanoidRootPart.CFrame -- Store the original position

            -- Teleport to the armor shop
            Character.HumanoidRootPart.CFrame = ArmorShop.Head.CFrame

            -- Simulate clicking the purchase button
            local clickDetector = ArmorShop:FindFirstChild("ClickDetector")
            if clickDetector then
                for i = 1, 5 do
                    fireclickdetector(clickDetector) -- Simulate clicking the detector
                    wait(0.1)
                end
            end

            -- Wait for armor to refill or funds to deplete
            repeat
                wait(0.01)
            until Armor.Value >= 100 or Player.DataFolder.Currency.Value < ArmorCost

            -- Teleport back to the original position
            Character.HumanoidRootPart.CFrame = originalPosition
        end

        wait(0.01) -- Check every half second
    end
end

-- Function to toggle Auto Armor
local function toggleAutoArmor(state)
    buyingActive = state

    if buyingActive then
        announce("Auto Armor Activated", "Armor will be auto-purchased", 5)

        -- Start the auto armor loop in a coroutine
        coroutine.wrap(buyArmor)()
    else
        announce("Auto Armor Deactivated", "Armor auto-purchase stopped", 5)
    end
end

-- Toggle button for enabling/disabling Auto Armor
Players_Main:Toggle({
    Name = "Automatic Armor",
    Default = false,
    Pointer = "AutoArmor_Enabled",
    Callback = function(state)
        toggleAutoArmor(state) -- Enable/Disable Auto Armor when toggled
    end
})




Players_Main:Slider({
    Name = "Automatic Armor Threshold",
    Minimum = 1,
    Maximum = 100,
    Default = 30,
    Decimals = 1,
    Pointer = "OrbitDistance_Slider",
    Callback = function(value)
        PERCENT_TO_BUY_ARMOR = value
    end
})




local healthThreshold = 50

function announce(title, text, time)
    game.StarterGui:SetCore("SendNotification", {Title = title, Text = text, Duration = time})
end

function buyAndEatPizza()
    while buyingActive do
        local Character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local health = Character:FindFirstChildOfClass("Humanoid").Health
        if health <= healthThreshold and game.Players.LocalPlayer.DataFolder.Currency.Value >= 5 then
            Character.HumanoidRootPart.CFrame = game:GetService("Workspace").Ignored.Shop["[Pizza] - $5"].Head.CFrame
            for _ = 1, 5 do fireclickdetector(game:GetService("Workspace").Ignored.Shop["[Pizza] - $5"]:FindFirstChild("ClickDetector")) wait(0.1) end
            
            Character.HumanoidRootPart.CFrame = CFrame.new(math.random(-99999999999999999, 99999999999999999), 10, math.random(-99999999999999999, 99999999999999999))
            
            if game.Players.LocalPlayer.Backpack:FindFirstChild("[Pizza]") then
                game.Players.LocalPlayer.Backpack.Pizza.Parent = Character
                wait(0.2) -- Ensure it's equipped before eating
                for _ = 1, 10 do game:GetService("VirtualUser"):ClickButton1(Vector2.new()) wait(0.1) end
            end
        end
        wait(0.5)
    end
end

function toggleAutoPizza(state)
    buyingActive = state
    announce("Auto Pizza " .. (state and "Activated" or "Deactivated"), state and "Auto-buying and eating pizza when health is low" or "Stopped auto pizza buying", 5)
    if state then coroutine.wrap(buyAndEatPizza)() end
end

Players_Main:Toggle({
    Name = "Automatic Pizza",
    Default = false,
    Pointer = "AutoPizza_Enabled",
    Callback = function(state) toggleAutoPizza(state) end
})




Players_Main:Slider({
    Name = "Automatic pizza",
    Minimum = 1,
    Maximum = 100,
    Default = 30,
    Decimals = 1,
    Pointer = "OrbitDistance_Slider",
    Callback = function(value)
        healthThreshold = value
    end
})



--[[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DefaultChatEvents = ReplicatedStorage.DefaultChatSystemChatEvents

local Messages = {
    "loser vibes? not with $$$$kid$$$$en$$$$e",
    "silence is the best answer for a fool",
    "can't beat $$$$kid$$$$en$$$$e? thats common",
    "why can't nobody beat me?!",
    "cop $$$$kid$$$$en$$$$e",
    "ALERT!! random detected",
    "ALERT!! nn detected",
    "$$$$kid$$$$en$$$$e will put you to sleep",
    "silence my dog"
}

-- Function to send chat messages
local function sendMessage(message)
    DefaultChatEvents.SayMessageRequest:FireServer(message, "All")
end

-- Function to start the auto-report process
local function startAutoReport()
    while true do
        for _, message in ipairs(Messages) do
            if not isActive then return end -- Stop if not active
            sendMessage(message) -- Send the current message
            wait(1) -- Delay before sending the next message
        end
    end
end

-- Function to toggle auto-reporting on/off
local function toggleAutoReport(state)
    isActive = state
    if isActive then
        
        startAutoReport() -- Start the loop if enabled
    else
        
    end
end

-- Toggle for the auto-reporting feature
Players_Main:Toggle({
    Name = "$$$$kid$$$$en$$$$e ShitTalk",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
        toggleAutoReport(state) -- Toggle the feature based on the button
    end
})

-- Stop auto-reporting if the player respawns
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    isActive = false -- Reset state on character respawn
    
end)]]




local Services = {
    RunService = game:GetService("RunService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage")
}

local stompConnection -- Connection for the Heartbeat event

-- Auto Stomp Functions
function stompLoopFunction()
    Services.ReplicatedStorage.MainEvent:FireServer("Stomp")
end

function toggleAutoStomp(state)
    if state then
        stompConnection = Services.RunService.Heartbeat:Connect(stompLoopFunction)
    else
        if stompConnection then
            stompConnection:Disconnect()
            stompConnection = nil
        end
    end
end

-- Toggle for Auto Stomp
Players_Main:Toggle({
    Name = "Automatic Stomp",
    Default = false,
    Pointer = "VisualsEnemies_AutoStomp",
    Callback = toggleAutoStomp
})




local blockDelay = 0.01
local unblockDelay = 0.01

-- Block Spamming Functions
function spamBlock()
    while spamEnabled do
        ReplicatedStorage.MainEvent:FireServer("Block", true)
        task.wait(blockDelay)
        ReplicatedStorage.MainEvent:FireServer("Block", false)
        task.wait(unblockDelay) -- Ensure it waits a small amount of time
    end
end

function toggleSpam(state)
    if state then
        spamEnabled = true
        coroutine.wrap(spamBlock)() -- Start the spam coroutine
    else
        spamEnabled = false
    end
end

-- Toggle for Block Spam
Players_Main:Toggle({
    Name = "God Block",
    Default = false,
    Pointer = "BlockSpam_Enabled",
    Callback = toggleSpam,
})

Players_Main:Slider({
    Name = "Delay To Block",
    Minimum = 0,
    Maximum = 1,
    Default = 0.01,
    Decimals = 0.01,
    Pointer = "BlockDelay_Slider", -- Unique pointer
    Callback = function(value)
        blockDelay = value
    end
})

Players_Main:Slider({
    Name = "Delay To UnBlock",
    Minimum = 0, -- Minimum should not be 0
    Maximum = 1,
    Default = 0.01,
    Decimals = 0.01,
    Pointer = "UnblockDelay_Slider", -- Unique pointer
    Callback = function(value)
        unblockDelay = value
    end
})








-- Replace this with your emote animation ID
local animationId = "rbxassetid://5917459365"
local animation = Instance.new("Animation")
animation.AnimationId = animationId

local emoteEnabled = false -- Toggle state for emote
local track

-- Function to play the emote continuously
function playEmote()
    if emoteEnabled and track and not track.IsPlaying then
        track:Play()
    end
end

-- Function to stop the emote
function stopEmote()
    if track and track.IsPlaying then
        track:Stop()
    end
end

-- Function to set up the character and animation when respawning
function setupCharacter(newCharacter)
    local humanoid = newCharacter:WaitForChild("Humanoid")
    track = humanoid:LoadAnimation(animation)

    -- Set the animation to loop
    track.Looped = true

    -- Stop the default walking animation while emote is active
    humanoid.Running:Connect(function(speed)
        if emoteEnabled and speed > 0 then
            humanoid:Move(Vector3.new(0, 0, 0), true) -- Prevent default animations
        end
    end)

    -- Ensure the animation keeps playing
    RunService.Heartbeat:Connect(function()
        if emoteEnabled then
            playEmote()
        elseif track and track.IsPlaying then
            stopEmote()
        end
    end)
end

-- Function to handle the toggle logic
function toggleEmote(state)
    emoteEnabled = state
    if emoteEnabled then
        playEmote()
    else
        stopEmote()
    end
end

-- Connect the character setup function to respawn
game.Players.LocalPlayer.CharacterAdded:Connect(setupCharacter)

-- Initialize the setup for the current character
setupCharacter(game.Players.LocalPlayer.Character)

-- Toggle function to enable/disable the emote
Players_Main:Toggle({
    Name = "Floss Walk",
    Default = false,
    Pointer = "EmoteLoop_Toggle",
    Callback = function(state)
        toggleEmote(state) -- Toggle the state based on the toggle button state
    end,
})












-- Global Variables
RunService1 = game:GetService("RunService")
Players1 = game:GetService("Players")
gameReplicatedStorage1 = game:GetService("ReplicatedStorage")

-- Replace this with your emote animation ID
animationId1 = "rbxassetid://11394033602"
animation1 = Instance.new("Animation")
animation1.AnimationId = animationId1

emoteEnabled1 = false -- Toggle state for emote
track1 = nil

-- Function to play the emote continuously
function playEmote1()
    if emoteEnabled1 and track1 and not track1.IsPlaying then
        track1:Play()
    end
end

-- Function to stop the emote
function stopEmote1()
    if track1 and track1.IsPlaying then
        track1:Stop()
    end
end

-- Function to set up the character and animation when respawning
function setupCharacter1(newCharacter)
    humanoid1 = newCharacter:WaitForChild("Humanoid")
    track1 = humanoid1:LoadAnimation(animation1)

    -- Set the animation to loop
    track1.Looped = true

    -- Stop the default walking animation while emote is active
    humanoid1.Running:Connect(function(speed)
        if emoteEnabled1 and speed > 0 then
            humanoid1:Move(Vector3.new(0, 0, 0), true) -- Prevent default animations
        end
    end)

    -- Ensure the animation keeps playing
    RunService1.Heartbeat:Connect(function()
        if emoteEnabled1 then
            playEmote1()
        elseif track1 and track1.IsPlaying then
            stopEmote1()
        end
    end)
end

-- Function to handle the toggle logic
function toggleEmote1(state)
    emoteEnabled1 = state
    if emoteEnabled1 then
        playEmote1()
    else
        stopEmote1()
    end
end

-- Connect the character setup function to respawn
Players1.LocalPlayer.CharacterAdded:Connect(setupCharacter1)

-- Initialize the setup for the current character
setupCharacter1(Players1.LocalPlayer.Character)

-- Toggle function to enable/disable the emote
Players_Main:Toggle({
    Name = "Elevate Walk",
    Default = false,
    Pointer = "EmoteLoop_Toggle1",
    Callback = function(state)
        toggleEmote1(state) -- Toggle the state based on the toggle button state
    end,
})




RunService2 = game:GetService("RunService")
Players2 = game:GetService("Players")
gameReplicatedStorage2 = game:GetService("ReplicatedStorage")

-- Replace this with your emote animation ID
animationId2 = "rbxassetid://15609995579"
animation2 = Instance.new("Animation")
animation2.AnimationId = animationId2

emoteEnabled2 = false -- Toggle state for emote
track2 = nil

-- Function to play the emote continuously
function playEmote2()
    if emoteEnabled2 and track2 and not track2.IsPlaying then
        track2:Play()
    end
end

-- Function to stop the emote
function stopEmote2()
    if track2 and track2.IsPlaying then
        track2:Stop()
    end
end

-- Function to set up the character and animation when respawning
function setupCharacter2(newCharacter)
    humanoid2 = newCharacter:WaitForChild("Humanoid")
    track2 = humanoid2:LoadAnimation(animation2)

    -- Set the animation to loop
    track2.Looped = true

    -- Stop the default walking animation while emote is active
    humanoid2.Running:Connect(function(speed)
        if emoteEnabled2 and speed > 0 then
            humanoid2:Move(Vector3.new(0, 0, 0), true) -- Prevent default animations
        end
    end)

    -- Ensure the animation keeps playing
    RunService2.Heartbeat:Connect(function()
        if emoteEnabled2 then
            playEmote2()
        elseif track2 and track2.IsPlaying then
            stopEmote2()
        end
    end)
end

-- Function to handle the toggle logic
function toggleEmote2(state)
    emoteEnabled2 = state
    if emoteEnabled2 then
        playEmote2()
    else
        stopEmote2()
    end
end

-- Connect the character setup function to respawn
Players2.LocalPlayer.CharacterAdded:Connect(setupCharacter2)

-- Initialize the setup for the current character
setupCharacter2(Players2.LocalPlayer.Character)

-- Toggle function to enable/disable the emote
Players_Main:Toggle({
    Name = "Yungblud Happier Jump Walk",
    Default = false,
    Pointer = "EmoteLoop_Toggle2",
    Callback = function(state)
        toggleEmote2(state) -- Toggle the state based on the toggle button state
    end,
})





RunService3 = game:GetService("RunService")
Players3 = game:GetService("Players")
gameReplicatedStorage3 = game:GetService("ReplicatedStorage")

-- Replace this with your emote animation ID
animationId3 = "rbxassetid://15693621070"
animation3 = Instance.new("Animation")
animation3.AnimationId = animationId3

emoteEnabled3 = false -- Toggle state for emote
track3 = nil

-- Function to play the emote continuously
function playEmote3()
    if emoteEnabled3 and track3 and not track3.IsPlaying then
        track3:Play()
    end
end

-- Function to stop the emote
function stopEmote3()
    if track3 and track3.IsPlaying then
        track3:Stop()
    end
end

-- Function to set up the character and animation when respawning
function setupCharacter3(newCharacter)
    humanoid3 = newCharacter:WaitForChild("Humanoid")
    track3 = humanoid3:LoadAnimation(animation3)

    -- Set the animation to loop
    track3.Looped = true

    -- Stop the default walking animation while emote is active
    humanoid3.Running:Connect(function(speed)
        if emoteEnabled3 and speed > 0 then
            humanoid3:Move(Vector3.new(0, 0, 0), true) -- Prevent default animations
        end
    end)

    -- Ensure the animation keeps playing
    RunService3.Heartbeat:Connect(function()
        if emoteEnabled3 then
            playEmote3()
        elseif track3 and track3.IsPlaying then
            stopEmote3()
        end
    end)
end

-- Function to handle the toggle logic
function toggleEmote3(state)
    emoteEnabled3 = state
    if emoteEnabled3 then
        playEmote3()
    else
        stopEmote3()
    end
end

-- Connect the character setup function to respawn
Players3.LocalPlayer.CharacterAdded:Connect(setupCharacter3)

-- Initialize the setup for the current character
setupCharacter3(Players3.LocalPlayer.Character)

-- Toggle function to enable/disable the emote
Players_Main:Toggle({
    Name = "Backflip Walk",
    Default = false,
    Pointer = "EmoteLoop_Toggle3",
    Callback = function(state)
        toggleEmote3(state) -- Toggle the state based on the toggle button state
    end,
})





RunService4 = game:GetService("RunService")
Players4 = game:GetService("Players")
gameReplicatedStorage4 = game:GetService("ReplicatedStorage")

-- Replace this with your emote animation ID
animationId4 = "rbxassetid://18665811005"
animation4 = Instance.new("Animation")
animation4.AnimationId = animationId4

emoteEnabled4 = false -- Toggle state for emote
track4 = nil

-- Function to play the emote continuously
function playEmote4()
    if emoteEnabled4 and track4 and not track4.IsPlaying then
        track4:Play()
    end
end

-- Function to stop the emote
function stopEmote4()
    if track4 and track4.IsPlaying then
        track4:Stop()
    end
end

-- Function to set up the character and animation when respawning
function setupCharacter4(newCharacter)
    humanoid4 = newCharacter:WaitForChild("Humanoid")
    track4 = humanoid4:LoadAnimation(animation4)

    -- Set the animation to loop
    track4.Looped = true

    -- Stop the default walking animation while emote is active
    humanoid4.Running:Connect(function(speed)
        if emoteEnabled4 and speed > 0 then
            humanoid4:Move(Vector3.new(0, 0, 0), true) -- Prevent default animations
        end
    end)

    -- Ensure the animation keeps playing
    RunService4.Heartbeat:Connect(function()
        if emoteEnabled4 then
            playEmote4()
        elseif track4 and track4.IsPlaying then
            stopEmote4()
        end
    end)
end

-- Function to handle the toggle logic
function toggleEmote4(state)
    emoteEnabled4 = state
    if emoteEnabled4 then
        playEmote4()
    else
        stopEmote4()
    end
end

-- Connect the character setup function to respawn
Players4.LocalPlayer.CharacterAdded:Connect(setupCharacter4)

-- Initialize the setup for the current character
setupCharacter4(Players4.LocalPlayer.Character)

-- Toggle function to enable/disable the emote
Players_Main:Toggle({
    Name = "TMNT Walk",
    Default = false,
    Pointer = "EmoteLoop_Toggle4",
    Callback = function(state)
        toggleEmote4(state) -- Toggle the state based on the toggle button state
    end,
})




RunService5 = game:GetService("RunService")
Players5 = game:GetService("Players")
gameReplicatedStorage5 = game:GetService("ReplicatedStorage")

-- Replace this with your emote animation ID
animationId5 = "rbxassetid://12992262118"
animation5 = Instance.new("Animation")
animation5.AnimationId = animationId5

emoteEnabled5 = false -- Toggle state for emote
track5 = nil

-- Function to play the emote continuously
function playEmote5()
    if emoteEnabled5 and track5 and not track5.IsPlaying then
        track5:Play()
    end
end

-- Function to stop the emote
function stopEmote5()
    if track5 and track5.IsPlaying then
        track5:Stop()
    end
end

-- Function to set up the character and animation when respawning
function setupCharacter5(newCharacter)
    humanoid5 = newCharacter:WaitForChild("Humanoid")
    track5 = humanoid5:LoadAnimation(animation5)

    -- Set the animation to loop
    track5.Looped = true

    -- Stop the default walking animation while emote is active
    humanoid5.Running:Connect(function(speed)
        if emoteEnabled5 and speed > 0 then
            humanoid5:Move(Vector3.new(0, 0, 0), true) -- Prevent default animations
        end
    end)

    -- Ensure the animation keeps playing
    RunService5.Heartbeat:Connect(function()
        if emoteEnabled5 then
            playEmote5()
        elseif track5 and track5.IsPlaying then
            stopEmote5()
        end
    end)
end

-- Function to handle the toggle logic
function toggleEmote5(state)
    emoteEnabled5 = state
    if emoteEnabled5 then
        playEmote5()
    else
        stopEmote5()
    end
end

-- Connect the character setup function to respawn
Players5.LocalPlayer.CharacterAdded:Connect(setupCharacter5)

-- Initialize the setup for the current character
setupCharacter5(Players5.LocalPlayer.Character)

-- Toggle function to enable/disable the emote
Players_Main:Toggle({
    Name = "Rise Above - The Chainsmokers Walk",
    Default = false,
    Pointer = "EmoteLoop_Toggle5",
    Callback = function(state)
        toggleEmote5(state) -- Toggle the state based on the toggle button state
    end,
})






local Services = {
    RunService = game:GetService("RunService")
}

local voidPosition = Vector3.new(0, -0, 10) -- Position of the void
local teleportEnabled = false -- Flag to check if teleporting is enabled
local healthThreshold = 50 -- Default health threshold

-- Function to teleport the player to the void
function teleportToVoid(humanoidRootPart)
    if humanoidRootPart then
        humanoidRootPart.CFrame = CFrame.new(voidPosition)
    end
end

-- Monitor health and teleport if health is below the threshold
function monitorHealthStatus(Humanoid)
    Services.RunService.Heartbeat:Connect(function()
        if teleportEnabled and Humanoid and Humanoid.Health < healthThreshold then
            teleportToVoid(Humanoid.Parent:WaitForChild("HumanoidRootPart"))
        end
    end)
end

-- Function to toggle the teleport feature
function toggleVoidTeleport(state)
    teleportEnabled = state
end

-- Reset feature on character respawn
game.Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    local Humanoid = newCharacter:WaitForChild("Humanoid")
    monitorHealthStatus(Humanoid)
end)

-- Check on initial character
if game.Players.LocalPlayer.Character then
    local Humanoid = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
    monitorHealthStatus(Humanoid)
end

-- Create a toggle button for the teleport feature
Players_Main:Toggle({
    Name = "Teleport to Void on Low Health",
    Default = false,
    Pointer = "VoidTeleport_Toggle",
    Callback = toggleVoidTeleport
})

-- Create a slider to set the health threshold
Players_Main:Slider({
    Name = "Health Threshold",
    Minimum = 1,
    Maximum = 100,
    Default = healthThreshold,
    Decimals = 1,
    Pointer = "HealthThreshold_Slider",
    Callback = function(value)
        healthThreshold = value
    end
})




Players_Main:Toggle({
    Name = "No Jump Cooldown",
    Default = false,
    Pointer = "DisableJump_Toggle",
    Callback = function(toggleState)
        if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
            game.Players.LocalPlayer.Character.Humanoid.UseJumpPower = not toggleState
        end
    end
})




local removingEffects = false  -- This will control whether the effects are being removed or not

-- Function to start removing effects
local function startRemovingEffects()
    removingEffects = true
    task.spawn(function()
        while removingEffects do
            -- Check if character is loaded
            local character = game.Players.LocalPlayer.Character
            if character then
                local bodyEffects = character:FindFirstChild("BodyEffects")
                if bodyEffects then
                    local movementFolder = bodyEffects:FindFirstChild("Movement")
                    if movementFolder then
                        -- Listen for any new objects being added and remove them
                        movementFolder.ChildAdded:Connect(function(child)
                            child:Destroy()
                        end)

                        -- Remove any existing objects immediately
                        for _, child in ipairs(movementFolder:GetChildren()) do
                            child:Destroy()
                        end
                    end
                    
                    -- Ensure Reload effect is always false
                    local reloadEffect = bodyEffects:FindFirstChild("Reload")
                    if reloadEffect and reloadEffect:IsA("BoolValue") and reloadEffect.Value then
                        reloadEffect.Value = false
                    end
                end
            end
            task.wait(0)
        end
    end)
end

-- Function to stop removing effects
function stopRemovingEffects()
    removingEffects = false
end

-- Toggle function using your framework
Players_Main:Toggle({
    Name = "Anti slow",
    Default = false,
    Pointer = "RemoveRestrictions_Toggle",
    Callback = function(state)
        if state then
            startRemovingEffects()  -- Start removing everything in the folder when enabled
        else
            stopRemovingEffects()  -- Stop removing effects when disabled
        end
    end
})




-- Global variables
predictionEnabled = false
teleportLoopRunning = false

-- Function to check and teleport
function startTeleportLoop()
    teleportLoopRunning = true
    while predictionEnabled do
        wait(0.1)

        local player = game.Players.LocalPlayer
        if not player or not player.Character then continue end

        local root = player.Character:FindFirstChild("HumanoidRootPart")
        local launcher = workspace:FindFirstChild("Ignored")
            and workspace.Ignored:FindFirstChild("Model")
            and workspace.Ignored.Model:FindFirstChild("Launcher")

        if root and launcher then
            local distance = (root.Position - launcher.Position).Magnitude
            
            -- If player enters 20-stud range, teleport instantly
            if distance <= 20 then
                local originalCFrame = root.CFrame
                root.CFrame = CFrame.new(0, 0, 10)
                wait(0.5)

                -- Only return if still enabled
                if predictionEnabled then
                    root.CFrame = originalCFrame
                end
            end
        end
    end
    teleportLoopRunning = false -- Reset so it can restart
end

-- Toggle UI
Players_Main:Toggle({
    Name = "Anti RPG",
    Default = false,
    Pointer = "Prediction_Toggle",
    Callback = function(state)
        predictionEnabled = state

        -- If enabled, start the loop properly
        if predictionEnabled and not teleportLoopRunning then
            startTeleportLoop()
        end
    end
})










--[[
local Services = {
    RunService = game:GetService("RunService"),
    Players = game:GetService("Players")
}

local isEnabled = false  -- Global flag to track whether SpinBot is enabled

-- Function to toggle the walking feature on/off with a unique name
function toggleSpinBot(state)
    isEnabled = state
    if isEnabled then
        
    else
        
    end
end

-- Connect the toggle button to this function
Players_Main:Toggle({
    Name = "SpinBot2",
    Default = false,
    Pointer = "WalkingFeature_Toggle",
    Callback = function(state)
        toggleSpinBot(state)
    end
})

-- Function to setup character connections and handle walking with a unique name
function handleCharacterWalking(character)
    local Humanoid = character:WaitForChild("Humanoid")
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local isWalking = false

    -- Monitor the running speed of the character (whether walking or not)
    Humanoid.Running:Connect(function(speed)
        isWalking = speed > 0
    end)

    -- Main logic controlled by the toggle
    Services.RunService.Heartbeat:Connect(function()
        if isEnabled then
            if isWalking then
                -- Logic for when the player is walking
                local originalVelocity = humanoidRootPart.AssemblyLinearVelocity
                humanoidRootPart.AssemblyLinearVelocity = Vector3.new(
                    math.random(-2000, 6000),
                    math.random(-13000, 3000),
                    math.random(-6000, 2000)
                )
                Services.RunService.RenderStepped:Wait()
                humanoidRootPart.AssemblyLinearVelocity = originalVelocity
            else
                -- Logic for when the player is not walking
                humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(0, math.rad(0.5), 0)
                local originalVelocity = humanoidRootPart.Velocity
                humanoidRootPart.Velocity = Vector3.new(0, -16384, 0)
                Services.RunService.RenderStepped:Wait()
                humanoidRootPart.Velocity = originalVelocity
            end
        end
    end)
end

-- Handle character respawn with a unique name
Services.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    handleCharacterWalking(character)
end)

-- Initialize the script for the current character with a unique name
if Services.Players.LocalPlayer.Character then
    handleCharacterWalking(Services.Players.LocalPlayer.Character)
end
]]








        end
        --
        do -- Visuals
        local Visuals_Main = Visuals2:Section({Name = Languages:GetTranslation("Main"), Fill = true, Side = "Left"})




-- Services
game:GetService("TweenService")
game:GetService("Players")
game:GetService("RunService")

-- Get player and mouse
player = game.Players.LocalPlayer
mouse = player:GetMouse()

-- Tween properties
fadeTime = 1  -- Default fade duration
fadeTween = nil  -- Will be recreated each time
predictionEnabled = false  -- Default toggle state

-- Function to create GUI and label
function createGUI()
    if player:FindFirstChild("PlayerGui") then
        -- Remove old GUI (prevents duplicates)
        if player.PlayerGui:FindFirstChild("InDayScreenGui") then
            player.PlayerGui:FindFirstChild("InDayScreenGui"):Destroy()
        end

        -- Create the screen GUI
        screenGui = Instance.new("ScreenGui")
        screenGui.Name = "InDayScreenGui"
        screenGui.Parent = player.PlayerGui

        -- Create the text label
        textLabel = Instance.new("TextLabel")
        textLabel.Parent = screenGui
        textLabel.Text = "InDay"
        textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        textLabel.BackgroundTransparency = 1
        textLabel.Size = UDim2.new(0, 100, 0, 50)
        textLabel.TextSize = 15
        textLabel.TextStrokeTransparency = 0.8
        textLabel.Visible = false  -- Start hidden
    end
end

-- Function to update position based on the mouse
function updatePosition()
    if textLabel then
        textLabel.Position = UDim2.new(0, mouse.X - textLabel.Size.X.Offset / 3, 0, mouse.Y + textLabel.Size.Y.Offset / 3)
    end
end

-- Function to create and start the fade tween
function startFadeTween()
    if textLabel then
        if fadeTween then
            fadeTween:Cancel()  -- Cancel any existing tween
        end
        textLabel.TextTransparency = 0  -- Reset transparency
        local tweenInfo = TweenInfo.new(fadeTime, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, -1, true)
        fadeTween = game:GetService("TweenService"):Create(textLabel, tweenInfo, {TextTransparency = 1})
        fadeTween:Play()
    end
end

-- Toggle for enabling/disabling the text
Visuals_Main:Toggle({
    Name = "InDay Text",
    Default = false,
    Pointer = "Text_Toggle",
    Callback = function(state)
        predictionEnabled = state
        if predictionEnabled then
            if not textLabel then
                createGUI()
            end
            textLabel.Visible = true
            startFadeTween()
        else
            if textLabel then
                textLabel.Visible = false
                if fadeTween then fadeTween:Cancel() end
            end
        end
    end
})

-- Slider for text size
Visuals_Main:Slider({
    Name = "Text Size",
    Minimum = 1,
    Maximum = 50,
    Default = 15,
    Decimals = 1,
    Pointer = "PredictionFactor_Slider",
    Callback = function(value)
        if textLabel then
            textLabel.TextSize = value
        end
    end
})

-- Slider for fade time
Visuals_Main:Slider({
    Name = "Fade Time",
    Minimum = 0.1,
    Maximum = 5,
    Default = 1,
    Decimals = 0.1,
    Pointer = "PredictionFactor_Slider",
    Callback = function(value)
        fadeTime = value
        if predictionEnabled then
            startFadeTween()
        end
    end
})


Visuals_Main:TextBox({
    Flag = "Custom_TextBox",
    Max = 50,  -- Max characters allowed
    PlaceHolder = "Enter Custom Text",  -- Placeholder text
    Callback = function(Text, Enter) 
        if Enter then
            if textLabel then
                textLabel.Text = Text  -- Update the text to user input
            end
        end
    end
})



-- Detect when player dies and recreate the GUI after respawn
player.CharacterAdded:Connect(function()
    wait(1)  -- Short delay to ensure GUI loads properly
    createGUI()
    if predictionEnabled then
        textLabel.Visible = true
        startFadeTween()
    end
end)

-- Update position when enabled
game:GetService("RunService").Heartbeat:Connect(function()
    if predictionEnabled and textLabel then
        updatePosition()
    end
end)









local isEffectEnabled, connection, spinningParts = false, nil, {}
local Aura1Distance, Aura1Speed, numberOfParts = 10, 50, 10 -- Local variables grouped

-- Cleanup the spinning parts and disconnect the event
local function cleanUpParts()
    for _, part in pairs(spinningParts) do
        part:Destroy()
    end
    spinningParts = {}
    if connection then
        connection:Disconnect()
        connection = nil
    end
end

-- Create the spinning parts
local function createSpinningParts()
    -- Only create parts if the effect is enabled
    for i = 1, math.floor(numberOfParts) do
        local part = Instance.new("Part", workspace)
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(255, 100, 255)
        part.Transparency = 0.5
        part.Size = Vector3.new(0.5, 0.5, 0.5)

        -- Particle emitter
        local emitter = Instance.new("ParticleEmitter", part)
        emitter.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.new(0, 0, 1)),
            ColorSequenceKeypoint.new(1, Color3.new(0, 1, 0))
        }
        emitter.LightEmission = 1
        emitter.Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 0)}
        emitter.Rate = 50
        emitter.Speed = NumberRange.new(2, 4)
        emitter.Lifetime = NumberRange.new(1, 2)

        -- Glow effect
        local glow = Instance.new("PointLight", part)
        glow.Color = Color3.fromRGB(255, 100, 255)
        glow.Range = 10
        glow.Brightness = 2

        table.insert(spinningParts, part)
    end
end

-- Function to handle spinning logic
local function startSpinning()
    local angle, height, direction = 0, 0, 1
    connection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
        if not isEffectEnabled then
            -- Stop everything if the effect is not enabled
            return
        end

        local rootPart = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            height = height + direction * deltaTime * 2
            if height > 3 then direction = -1 elseif height < -3 then direction = 1 end

            -- Orbit each part around the player
            for i, part in pairs(spinningParts) do
                local partAngle = angle + (i * math.pi * 2 / #spinningParts)  -- Offset each part's orbit position
                part.Position = rootPart.Position + Vector3.new(math.cos(partAngle) * Aura1Distance, height, math.sin(partAngle) * Aura1Distance)
            end

            angle = angle + deltaTime * Aura1Speed  -- Control the speed of the orbit
        end
    end)
end

-- Toggle to start/stop the spinning effect
function toggleSpinningEffect(state)
    isEffectEnabled = state
    cleanUpParts()  -- Clean up old parts and connection

    if isEffectEnabled then
        createSpinningParts()  -- Create new parts
        startSpinning()  -- Start spinning the parts
    end
end

-- Toggle to start/stop the spinning effect
Visuals_Main:Toggle({
    Name = "Aura",
    Default = false,
    Pointer = "SpinningEffect_Toggle",
    Callback = toggleSpinningEffect
})

-- Orbit Distance Slider
Visuals_Main:Slider({
    Name = "Aura Distance",
    Minimum = 1,
    Maximum = 100,
    Default = Aura1Distance,
    Decimals = 1,
    Pointer = "OrbitDistance_Slider",
    Callback = function(value)
        Aura1Distance = value
        if isEffectEnabled then
            toggleSpinningEffect(true) -- Restart effect to apply the new distance
        end
    end
})

-- Number of Parts Slider
Visuals_Main:Slider({
    Name = "Aura Number Of Parts",
    Minimum = 1,
    Maximum = 500,
    Default = numberOfParts,
    Decimals = 1,
    Pointer = "NumberOfParts_Slider",
    Callback = function(value)
        numberOfParts = value
        if isEffectEnabled then
            toggleSpinningEffect(true) -- Restart effect to apply the new number of parts
        end
    end
})

-- Aura Speed Slider
Visuals_Main:Slider({
    Name = "Aura Speed",
    Minimum = 1,
    Maximum = 500,
    Default = Aura1Speed,
    Decimals = 1,
    Pointer = "OrbitSpeed_Slider",
    Callback = function(value)
        Aura1Speed = value
    end
})






    Visuals_Main:Button({
    Name = "esp",
    Default = false,
    Pointer = "AimbotMain_Enabled",
    Callback = function(state)
    loadstring(game:HttpGet("https://raw.githubusercontent.com/bebepro/esp/refs/heads/main/esp"))()
    end})
end



        do -- Misc
            local Misc_Client, Misc_Custom = Misc:MultiSection({Sections = {Languages:GetTranslation("Main"), Languages:GetTranslation("Custom")}, Size = 347})
            local Misc_Movement = Misc:Section({Name = Languages:GetTranslation("Movement"), Side = "Right"})
            local Misc_Extra = Misc:Section({Name = Languages:GetTranslation("Extra"), Fill = true, Side = "Right"})
            local Misc_Chat = Misc:Section({Name = Languages:GetTranslation("Chat"), Fill = true})
            --
            Misc_Client:Toggle({Name = Languages:GetTranslation("Client Desync"), Flag = "MiscClient_Enabled"}):Keybind({Flag = "MiscClient_EnabledKey", Default = Enum.KeyCode.RightControl, KeybindName = Languages:GetTranslation("Client Desync"), Mode = "Toggle", Callback = function(Key, State)
                Desync.Enabled = State
                --
                if Atlanta:GetCharacter(Client) then
                    local Object, Humanoid, RootPart = Atlanta:ValidateClient(Client)
                    --
                    if RootPart then
                        if Desync.Enabled then
                            Atlanta.Locals.LastPosition = RootPart.CFrame
                            --
                            Desync.Fake.CFrame = RootPart.CFrame
                            Desync.Fake.Velocity = RootPart.Velocity
                            Desync.Fake.RotVelocity = RootPart.RotVelocity
                        else
                            if Desync.Real.CFrame and Desync.Real.Velocity and Desync.Real.RotVelocity then
                                RootPart.Velocity = Vector3.new(0, 0, 0)
                                RootPart.RotVelocity = Vector3.new(0, 0, 0)
                                --
                                RootPart.CFrame = Desync.Real.CFrame
                                RootPart.Velocity = Desync.Real.Velocity
                                RootPart.RotVelocity = Desync.Real.RotVelocity
                            end
                        end
                    end
                end
            end})
            Misc_Client:Slider({Name = Languages:GetTranslation("Speed"), Flag = "MiscClient_Speed", Default = 10, Maximum = 10, Minimum = 0.1, Decimals = 0.01})


 -- Function to get the player's character and humanoid root part
function getPlayerCharacter()
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    return character, humanoidRootPart
end

-- Function to handle speed boost logic (now with a speedMultiplier parameter)
function moveWithCFrame(speedMultiplier)
    local _, humanoidRootPart = getPlayerCharacter()
    while getSpeedBoostState() and getSpeedBoostKeybindState() and humanoidRootPart do
        local moveDirection = humanoidRootPart.Parent:FindFirstChild("Humanoid") and humanoidRootPart.Parent.Humanoid.MoveDirection
        if moveDirection and moveDirection.Magnitude > 0 then
            humanoidRootPart.CFrame = humanoidRootPart.CFrame + (moveDirection * speedMultiplier)
        end
        game:GetService("RunService").RenderStepped:Wait()
    end
end

-- State management for speed boost toggle and keybind
function setSpeedBoostState(state)
    _G.SpeedBoostEnabled = state -- Use global state for the toggle
end

function getSpeedBoostState()
    return _G.SpeedBoostEnabled or false -- Default to false if not set
end

function setSpeedBoostKeybindState(state)
    _G.SpeedBoostActive = state -- Use global state for the keybind
end

function getSpeedBoostKeybindState()
    return _G.SpeedBoostActive or false -- Default to false if not set
end

-- Function to handle speed multiplier change from the slider
function setSpeedMultiplier(value)
    _G.SpeedMultiplier = value
end

function getSpeedMultiplier()
    return _G.SpeedMultiplier or 1 -- Default to 1 if not set
end

-- UI Integration: Toggle and Keybind for Speed Boost
Misc_Movement:Toggle({
    Name = Languages:GetTranslation("Cframe Speed"), -- Display name for the toggle
    Flag = "SpeedBoost_Toggle", -- Unique identifier
    Callback = function(state)
        setSpeedBoostState(state) -- Enable or disable speed boost based on toggle state
        if state then
        else
            setSpeedBoostKeybindState(false) -- Ensure keybind is deactivated when toggle is off
        end
    end
}):Keybind({
    Flag = "SpeedBoost_Cframe", -- Unique identifier for the keybind
    Default = Enum.KeyCode.C, -- Default keybind
    KeybindName = Languages:GetTranslation("Speed Boost Key"), -- Display name for the keybind
    Mode = "Toggle", -- Keybind mode (Toggle behavior)
    Callback = function()
        if getSpeedBoostState() then
            -- Only activate/deactivate if the toggle is ON
            local keybindState = not getSpeedBoostKeybindState()
            setSpeedBoostKeybindState(keybindState)
            if keybindState then
                
                coroutine.wrap(moveWithCFrame)(getSpeedMultiplier()) -- Start movement coroutine with multiplier from slider
            else
                
            end
        else
            
        end
    end
})

-- UI Integration: Slider for Speed Multiplier
Misc_Movement:Slider({
    Name = Languages:GetTranslation("Speed"), -- Display name for the slider
    Flag = "SpeedBoost_Slider", -- Unique identifier for the slider
    Default = 2.6, -- Default speed multiplier
    Minimum = 0.1, -- Minimum value
    Maximum = 100, -- Maximum value
    Decimals = 0.1, -- Decimal precision
    Callback = function(value)
        setSpeedMultiplier(value) -- Update the global speed multiplier based on slider value
    end
})


-- Variables to control the teleportation loop
local teleporting = false

-- Function to start teleporting
function startTeleporting()
    teleporting = true
    while teleporting do
        -- Generate random large positions and rotations
        local randomX = math.random(-9999999999999, 9999999999999)
        local randomY = math.random(-9999999999999, 9999999999999)
        local randomZ = math.random(-9999999999999, 9999999999999)

        local randomAngleX = math.random(-9999999999999, 9999999999999)
        local randomAngleY = math.random(-9999999999999, 9999999999999)
        local randomAngleZ = math.random(-9999999999999, 9999999999999)

        -- Set random CFrame for teleportation
        Desync.Fake.CFrame = CFrame.new(randomX, randomY, randomZ)
            * CFrame.Angles(randomAngleX, randomAngleY, randomAngleZ)

        -- Small delay to prevent script from freezing
        wait(0.1)
    end
end

-- Function to stop teleporting
function stopTeleporting()
    teleporting = false
end

-- Add the toggle further down
Misc_Custom:Toggle({
    Name = "Random Teleport Doesn't work",
    Default = false,
    Pointer = "RandomTeleport_Toggle",
    Callback = function(toggleState)
        if toggleState then
            
            startTeleporting()
        else
            
            stopTeleporting()
        end
    end
})




local randomTeleportEnabled = false
local originalPosition = nil  -- Variable to store the original position of the player

-- Random teleport logic
function teleportLoop()
    while randomTeleportEnabled do
        local player = game.Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            -- Generate random coordinates in the range you want
            local newX = math.random(-100, 999999)  -- Random X in the range of -100 to 100
            local newY = math.random(999999, 999999)   -- Random Y (height) between 50 and 150
            local newZ = math.random(-100, 999999)  -- Random Z in the range of -100 to 100

            -- Apply the random teleport
            player.Character.HumanoidRootPart.CFrame = CFrame.new(newX, newY, newZ)
        end
        task.wait(0)  -- Add a small delay to prevent crashing or overload
    end
end

-- Toggle for enabling/disabling random teleport
Misc_Custom:Toggle({
    Name = "Anti Reign",
    Default = false,
    Pointer = "Random_Teleport_Toggle",
    Callback = function(state)
        local player = game.Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if state then
                -- Store the player's current position when teleportation starts
                originalPosition = player.Character.HumanoidRootPart.Position
                randomTeleportEnabled = true
                spawn(teleportLoop) -- Run teleport function in a separate thread
            else
                -- Teleport back to original position when turning off
                if originalPosition then
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(originalPosition)
                end
                randomTeleportEnabled = false
            end
        end
    end
})






            Misc_Client:Dropdown({Name = Languages:GetTranslation("Position Method"), Flag = "MiscClient_PositionMethod", Options = {"Off", "Head", "Under Floor", "In Air", "Floor Shift", "Air Shift", "Last Position", "Random", "Custom"}})
            Misc_Client:Dropdown({Name = Languages:GetTranslation("Turn Method"), Flag = "MiscClient_TurnMethod", Options = {"Off", "Rotate", "Backwards Shift", "Backwards", "Upside Down", "Laying", "Jitter", "Random", "Custom"}})
            Misc_Client:Dropdown({Name = Languages:GetTranslation("Turn Smoothing"), Flag = "MiscClient_TurnSmoothing", Options = {"Constant", "Reverse", "Inverse"}})
            Misc_Client:Dropdown({Name = Languages:GetTranslation("Easing Style"), Flag = "MiscClient_EasingStyle", Options = {"Off", "Linear", "Cubic", "Quad", "Quart", "Quint", "Sine", "Exponential", "Back", "Bounce", "Elastic", "Circular"}})
            Misc_Client:Dropdown({Name = Languages:GetTranslation("Easing Direction"), Flag = "MiscClient_EasingDirection", Options = {"In", "Out", "InOut"}})
            Misc_Client:Dropdown({Name = Languages:GetTranslation("Velocity Method"), Flag = "MiscClient_VelocityMethod", Options = {"Off", "StandBug", "Destroy Stand", "Furthest It Can Go", "Multiplier", "Reversed", "Up", "Down", "Left", "Right"}})
            Misc_Client:Slider({Name = Languages:GetTranslation("Velocity Multiplier"), Flag = "MiscClient_VelocityMultiplier", Default = 1000, Maximum = 1000, Minimum = 0, Decimals = 0.01})
            --Misc_Client:Label({Name = Languages:GetTranslation("Turn on Visualisation in Players,\nLocal Player to see the Desync.", Center = true})
            --
-- Global services
services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    Workspace = game.Workspace
}

-- Global variables
flying = false
flightSpeed = 50
defaultGravity = services.Workspace.Gravity
character = services.Players.LocalPlayer.Character or services.Players.LocalPlayer.CharacterAdded:Wait()
humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Functions
function GetHumanoid()
    return character:WaitForChild("Humanoid")
end

function StartFlying()
    local humanoid = GetHumanoid()
    humanoid.PlatformStand = true
    humanoid.UseJumpPower = false
    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    services.Workspace.Gravity = 0
end

function StopFlying()
    local humanoid = GetHumanoid()
    humanoid.PlatformStand = false
    humanoid.UseJumpPower = true
    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    services.Workspace.Gravity = defaultGravity
end

function ToggleFly(state)
    if state then
        if not flying then
            flying = true
            StartFlying()
        end
    else
        if flying then
            flying = false
            StopFlying()
        end
    end
end

function ControlFlight()
    if flying then
        local camera = services.Workspace.CurrentCamera
        local moveDirection = Vector3.new()

        local forward = camera.CFrame.LookVector
        local right = camera.CFrame.RightVector
        local up = Vector3.new(0, 1, 0)

        if services.UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDirection += forward
        end
        if services.UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDirection -= forward
        end
        if services.UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDirection -= right
        end
        if services.UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDirection += right
        end
        if services.UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveDirection += up
        end
        if services.UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveDirection -= up
        end

        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit * flightSpeed
        end

        humanoidRootPart.CFrame += moveDirection
    end
end

function SetFlightSpeed(value)
    flightSpeed = value
end

function SetupFlying()
    services.Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        character = newCharacter
        humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        if flying then
            StartFlying()
        end
    end)
end

-- Initialize Flight Setup
SetupFlying()

-- Flight Control
services.RunService.Heartbeat:Connect(function()
    ControlFlight()
end)

-- UI Integration (example UI callbacks)
Misc_Movement:Toggle({
    Name = "Fly",  -- Display name for the toggle
    Flag = "MiscMovement_Fly",  -- Unique identifier
    Callback = function(state)
        ToggleFly(state)
    end
}):Keybind({
    Flag = "MiscMovement_FlyKey",
    Default = Enum.KeyCode.F,
    KeybindName = "Fly Hack",
    Mode = "Toggle",
    Callback = function()
        ToggleFly(not flying)
    end
})

Misc_Movement:Slider({
    Name = "Fly Speed",
    Flag = "MiscMovement_FlyNum",
    Default = 7,
    Minimum = 1,
    Maximum = 300,
    Decimals = 1,
    Callback = function(value)
        SetFlightSpeed(value)
    end
})
            Misc_Extra:Toggle({Name = Languages:GetTranslation("Disable Networking"), Flag = "MiscExtra_DisableNetworking"}):Keybind({Flag = "MiscExtra_DisableNetworkingKey", Default = Enum.KeyCode.X, KeybindName = Languages:GetTranslation("Networking"), Mode = "Toggle"})
            Misc_Extra:Toggle({Name = Languages:GetTranslation("Fake Lag"), Flag = "MiscExtra_FakeLag"}):Keybind({Flag = "MiscExtra_FakeLagKey", Default = Enum.KeyCode.Minus, KeybindName = Languages:GetTranslation("Fake Lag"), Mode = "Toggle"})
            Misc_Extra:Slider({Name = Languages:GetTranslation("Fake Lag Ammount"), Flag = "MiscExtra_FakeLagAmmount", Ending = "t", Default = 50, Maximum = 1000, Minimum = 1, Decimals = 1})
            Misc_Extra:Slider({Name = Languages:GetTranslation("Fake Lag Multiplier"), Flag = "MiscExtra_FakeLagMultiplier", Ending = "t", Default = 1, Maximum = 20, Minimum = 0.1, Decimals = 0.001})
            Misc_Extra:Toggle({Name = Languages:GetTranslation("Return Desync"), Flag = "MiscExtra_Return"})
            Misc_Extra:Dropdown({Name = Languages:GetTranslation("Return Type"), Flag = "MiscExtra_ReturnType", Default = "Flip", Options = {"Always", "Flip"}})
            Misc_Extra:Toggle({Name = Languages:GetTranslation("Lag Switch"), Flag = "MiscExtra_LagSwitch"}):Keybind({Flag = "MiscExtra_LagSwitchKey", Default = Enum.KeyCode.Equals, KeybindName = Languages:GetTranslation("Lag Switch"), Mode = "On Hold"})
            Misc_Extra:Slider({Flag = "MiscExtra_LagSwitchAmmount", Ending = "rl", Default = 1, Maximum = 10, Minimum = 0.1, Decimals = 0.01})
            --
DefaultChatEvents = game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents

Messages = {
    "Anti trashmode services",
    "no comp fr",
    "loooser",
    "keep yapping nca",
    "successfully killed a nn",
    "ALERT!! random detected",
    "ALERT!! nn detected",
    "ill put u to sleep nn",
    "silence my dog"
}

isActive, keybindActive, spamDelay, reportCoroutine = false, false, 1, nil

function sendMessage(message)
    DefaultChatEvents.SayMessageRequest:FireServer(message, "All")
end

function startSpam()
    if reportCoroutine or not isActive or not keybindActive then return end
    reportCoroutine = coroutine.create(function()
        while isActive and keybindActive do
            for _, message in ipairs(Messages) do
                if not isActive or not keybindActive then break end
                sendMessage(message)
                wait(spamDelay)
            end
        end
    end)
    coroutine.resume(reportCoroutine)
end

function stopSpam()
    reportCoroutine = nil
end

Misc_Chat:Toggle({
    Name = "Chat Spam",
    Default = false,
    Pointer = "ChatSpam_Toggle",
    Callback = function(state)
        isActive = state
        if not state then
            keybindActive = false
            stopSpam()
        end
    end
}):Keybind({
    Default = Enum.KeyCode.J,
    KeybindName = "Toggle Spam",
    Mode = "Toggle",
    Pointer = "ChatSpam_Keybind",
    Callback = function()
        keybindActive = not keybindActive
        if keybindActive then
            startSpam()
        else
            stopSpam()
        end
    end
})

Misc_Chat:Slider({
    Name = "Spam Delay (Seconds)",
    Minimum = 0.1,
    Maximum = 5,
    Default = 1,
    Decimals = 0.1,
    Pointer = "ChatSpam_Delay",
    Callback = function(value)
        spamDelay = value
    end
})

game.Players.LocalPlayer.CharacterAdded:Connect(function()
    isActive = false
    keybindActive = false
    stopSpam()
end)

            Misc_Chat:Dropdown({Name = Languages:GetTranslation("Chat Spam Type"), Flag = "MiscChat_Type", Default = "Atlanta", Options = {"Atlanta", "Troll", "Toxic", "Fulcrum", "Custom", "Song"}})
            Misc_Chat:TextBox({Flag = "MiscChat_Song", Max = 50, PlaceHolder = Languages:GetTranslation("Song Name"), Callback = function(Text, Enter) if Enter then Chat:GenerateSong(Text) end end})
            Misc_Chat:Toggle({Name = Languages:GetTranslation("Multiple"), Flag = "MiscChat_Multiple", Default = true})
            Misc_Chat:Toggle({Name = Languages:GetTranslation("Emojis"), Flag = "MiscChat_Emojis", Default = true})
            Misc_Chat:Toggle({Name = Languages:GetTranslation("Symbols"), Flag = "MiscChat_Symbols", Default = true})
        end
        --
        do -- Settings
            local Settings_PlayerList = Settings:PlayerList({})
            local Settings_Main = Settings:Section({Name = Languages:GetTranslation("Main"), Fill = true})
            local Settings_Extra = Settings:Section({Name = Languages:GetTranslation("Extra"), Fill = true, Side = "Right"})
            --
            Settings_Main:Toggle({Name = Languages:GetTranslation("Deatmatch Mode"), Flag = "SettingsMain_Deathmatch"})
            --
            Settings_Extra:Label({Name = Languages:GetTranslation("Server ID")})
            Settings_Extra:TextBox({Default = game.JobId, Max = 200, Reactive = false, PlaceHolder = "Server ID"})
            Settings_Extra:Button({Name = Languages:GetTranslation("Rejoin Server"), Callback = Atlanta.Rejoin})
        end
        --
        do -- Config
            local Config_Menu = Config:Section({Name = Languages:GetTranslation("Menu")})
            local Config_Configuration = Config:Section({Name = Languages:GetTranslation("Configuration"), Side = "Right"})
            local Config_Theme = Config:Section({Name = Languages:GetTranslation("Theme")})
            local Config_Load = Config:Section({Name = Languages:GetTranslation("Load"), Fill = true, Side = "Right"})
            local Config_Extra = Config:Section({Name = Languages:GetTranslation("Extra"), Fill = true})
            --
            Config_Menu:Keybind({Name = Languages:GetTranslation("Toggle"), Flag = "ConfigMenu_MenuToggle", Default = Enum.KeyCode.RightControl, KeybindName = Languages:GetTranslation("Menu Key"), Mode = "Toggle", Callback = function(Input, Active) Window.uibind = Input end})
            Config_Menu:Toggle({Name = Languages:GetTranslation("Custom Menu Name"), Flag = "ConfigMenu_CustomName", Default = false, Callback = function(State)
                if State and Flags.ConfigMenu_Name and Flags.ConfigMenu_Name:Get() then
                    Window:SetName(("%s - %s - (%s)"):format(Flags["ConfigMenu_Name"]:Get(), Atlanta.Account.Username, game.PlaceId)) 
                    Window.wminfo = (Languages:GetTranslation("[%s]  -  [Account = $ACC [$UID],  Build = $BUILD,  Ping = $PING,  FPS = $FPS]")):format(Flags["ConfigMenu_Name"]:Get()):gsub("$BUILD", "Developer"):gsub("$ACC", Atlanta.Account.Username):gsub("$UID", Atlanta.Account.UserID)
                else
                    Window:SetName(("%s - %s - (%s)"):format("InDay", Atlanta.Account.Username, game.PlaceId))
                    Window.wminfo = (Languages:GetTranslation("[%s]  -  [Account = $ACC [$UID],  Build = $BUILD,  Ping = $PING,  FPS = $FPS]")):format("InDay"):gsub("$BUILD", "Developer"):gsub("$ACC", Atlanta.Account.Username):gsub("$UID", Atlanta.Account.UserID)
                end
            end})
            Config_Menu:TextBox({Flag = "ConfigMenu_Name", Default = "InDay", Max = 50, PlaceHolder = "Menu Name", Callback = function(State)
                if Flags["ConfigMenu_CustomName"]:Get() then
                    Window:SetName(("%s - %s - (%s)"):format(State, Atlanta.Account.Username, game.PlaceId))
                    Window.wminfo = (Languages:GetTranslation("[%s]  -  [Account = $ACC [$UID],  Build = $BUILD,  Ping = $PING,  FPS = $FPS]")):format(Flags["ConfigMenu_Name"]:Get()):gsub("$BUILD", "Developer"):gsub("$ACC", Atlanta.Account.Username):gsub("$UID", Atlanta.Account.UserID)
                end
            end})
            --
            Config_Configuration:List({Flag = "ConfigConfiguration_Box", Options = Atlanta.Configs}) 
            Config_Configuration:TextBox({Flag = "ConfigConfiguration_Name", Name = Languages:GetTranslation("Config Name"), Default = "", Max = 20, PlaceHolder = "Config Name", Callback = function(Text) end})
            Config_Configuration:ButtonHolder({Buttons = {{"Create", function() Library:PerformConfigAction(Flags["ConfigConfiguration_Name"]:Get(), "Save") end}, {"Delete", function() Library:PerformConfigAction(Flags["ConfigConfiguration_Box"]:Get(), "Delete") end}}})
            Config_Configuration:ButtonHolder({Buttons = {{"Load", function() Library:PerformConfigAction(Flags["ConfigConfiguration_Box"]:Get(), "Load") end}, {"Save", function() Library:PerformConfigAction(Flags["ConfigConfiguration_Box"]:Get(), "Save") end}}})
            Config_Configuration:Button({Name = Languages:GetTranslation("Unload"), Callback = Atlanta.Unload})
            --
            Config_Theme:Dropdown({Name = Languages:GetTranslation("Theme"), Flag = "ConfigTheme_Theme", Default = "Default", Max = 8, Options = Utility:GetTableIndexes(Themes, true)})
            Config_Theme:Button({Name = Languages:GetTranslation("Load"), Callback = function() Library:LoadTheme(Flags.ConfigTheme_Theme:Get()) end})
            Config_Theme:Colorpicker({Name = Languages:GetTranslation("Accent"), Flag = "ConfigTheme_Accent", Default = Color3.fromRGB(112, 107, 139), Callback = function(Color) Library:UpdateColor("Accent", Color) end})
            Config_Theme:Colorpicker({Name = Languages:GetTranslation("Light Contrast"), Flag = "ConfigTheme_LightContrast", Default = Color3.fromRGB(30, 30, 30), Callback = function(Color) Library:UpdateColor("LightContrast", Color) end})
            Config_Theme:Colorpicker({Name = Languages:GetTranslation("Dark Contrast"), Flag = "ConfigTheme_DarkContrast", Default = Color3.fromRGB(20, 20, 20), Callback = function(Color) Library:UpdateColor("DarkContrast", Color) end})
            Config_Theme:Colorpicker({Name = Languages:GetTranslation("Outline"), Flag = "ConfigTheme_Outline", Default = Color3.fromRGB(0, 0, 0), Callback = function(Color) Library:UpdateColor("Outline", Color) end})
            Config_Theme:Colorpicker({Name = Languages:GetTranslation("Inline"), Flag = "ConfigTheme_Inline", Default = Color3.fromRGB(50, 50, 50), Callback = function(Color) Library:UpdateColor("Inline", Color) end})
            Config_Theme:Colorpicker({Name = Languages:GetTranslation("Light Text"), Flag = "ConfigTheme_LightText", Default = Color3.fromRGB(255, 255, 255), Callback = function(Color) Library:UpdateColor("TextColor", Color) end})
            Config_Theme:Colorpicker({Name = Languages:GetTranslation("Dark Text"), Flag = "ConfigTheme_DarkText", Default = Color3.fromRGB(175, 175, 175), Callback = function(Color) Library:UpdateColor("TextDark", Color) end})
            Config_Theme:Colorpicker({Name = Languages:GetTranslation("Text Outline"), Flag = "ConfigTheme_TextBorder", Default = Color3.fromRGB(0, 0, 0), Callback = function(Color) Library:UpdateColor("TextBorder", Color) end})
            Config_Theme:Colorpicker({Name = Languages:GetTranslation("Cursor Outline"), Flag = "ConfigTheme_CursorOutline", Default = Color3.fromRGB(255, 255, 204), Callback = function(Color) Library:UpdateColor("CursorOutline", Color) end})
            Config_Theme:Dropdown({Name = Languages:GetTranslation("Accent Effect"), Flag = "ConfigTheme_AccentEffect", Default = "None", Options = {"None", "Rainbow", "Shift", "Reverse Shift"}, Callback = function(State) if State == "None" then Library:UpdateColor("Accent", Flags["ConfigTheme_Accent"]:Get()) end end})
            Config_Theme:Slider({Name = Languages:GetTranslation("Effect Length"), Flag = "ConfigTheme_EffectLength", Default = 40, Maximum = 360, Minimum = 1, Decimals = 1})
            --
            Config_Load:Toggle({Name = Languages:GetTranslation("Show Menu"), Flag = "ConfigLoad_ShowMenu", Default = true})
            Config_Load:Toggle({Name = Languages:GetTranslation("Auto Load Config"), Flag = "ConfigLoad_AutoLoad", Default = false})
            --
            Config_Extra:Toggle({Name = Languages:GetTranslation("Show Watermark"), Flag = "ConfigExtra_Watermark", Callback = function(State) Window.watermark:Update("Visible", State) end})
            Config_Extra:Toggle({Name = Languages:GetTranslation("Show Keybinds"), Flag = "ConfigExtra_KBList", Callback = function(State) Window.keybindslist:Update("Visible", State) end})
            Config_Extra:Toggle({Name = Languages:GetTranslation("Show Statuses"), Flag = "ConfigExtra_StatusList", Callback = function(State) Window.statuslist:Update("Visible", State) end})
        end
    end
    --
    do -- // Main
        do -- Connections
            RunService:BindToRenderStep("Desync", Enum.RenderPriority.First.Value, function()
                if Desync.Enabled then
                    local Object, Humanoid, RootPart = Atlanta:ValidateClient(Client)
                    local Head = (Object and Object:FindFirstChild("Head"))
                    --
                    if RootPart and Head then
                        local PositionMethod = Flags["MiscClient_PositionMethod"]:Get()
                        local TurnMethod = Flags["MiscClient_TurnMethod"]:Get()
                        local TurnSmoothing = Flags["MiscClient_TurnSmoothing"]:Get()
                        local EasingStyle = Flags["MiscClient_EasingStyle"]:Get()
                        local EasingDirection = Flags["MiscClient_EasingDirection"]:Get()
                        local VelocityMethod = Flags["MiscClient_VelocityMethod"]:Get()
                        local VelocityMultiplier = Flags["MiscClient_VelocityMultiplier"]:Get()
                        --
                        Desync.SmoothValue = Desync.SmoothValue + ((TurnMethod == "Rotate" and 0.0025 or 0.005) * Flags["MiscClient_Speed"]:Get())
                        local Smoothened = (EasingStyle ~= "Off" and Math:Shift(Desync.SmoothValue) or (TurnSmoothing == "Constant" and Desync.SmoothValue or TurnSmoothing == "Reverse" and -Desync.SmoothValue or Math:Shift(Desync.SmoothValue)))
                        --
                        if TurnMethod == "Rotate" and Floor(Desync.SmoothValue * Desync.Rotate.X) > Desync.Rotate.X then
                            Window.statuslist:Add("Calculating Desync Rotation")
                            Desync.SmoothValue = 0
                            Smoothened = 0
                            --
                            Desync.Rotate2 = (Desync.Rotate2 + Desync.Rotate)
                            --
                            Desync.Rotate = Vector3.new(Random(150, 1600), Random(2, 600) / 2, Random(150, 1600))
                            --
                            Delay(0.5, function()
                                Window.statuslist:Remove("Calculating Desync Rotation")
                            end)
                        end
                        --
                        if EasingStyle ~= "Off" then
                            Smoothened = TurnSmoothing == "Reverse" and -Tween.EasingStyles[Enum.EasingStyle[EasingStyle]][Enum.EasingDirection[EasingDirection]](Smoothened) or Tween.EasingStyles[Enum.EasingStyle[EasingStyle]][Enum.EasingDirection[EasingDirection]](Smoothened)
                        end
                        --
                        if Desync.Sent.Position ~= RootPart.CFrame.Position then
                            Desync.Real.CFrame = RootPart.CFrame
                        end
                        --
                        RootPart.CFrame = Desync.Real.CFrame or RootPart.CFrame
                        RootPart.Velocity = Desync.Real.Velocity or RootPart.Velocity
                        RootPart.RotVelocity = Desync.Real.RotVelocity or RootPart.RotVelocity
                        --
                        local Length, Height, Width = Desync.Real.CFrame:ToOrientation()
                        --
                        local Position
                        local Turn
                        ---(Head and (RootPart.Size.Y + (Head.Size.Y * 3)) or 5)
                        if PositionMethod == "Head" then
                            Position = Desync.Real.CFrame.Position + Vector3.new(0, Head and (RootPart.Size.Y + (Head.Size.Y * 3)) or 5, 0)
                        elseif PositionMethod == "Under Floor" then
                            Position = Desync.Real.CFrame.Position + Vector3.new(0, -4, 0)
                        elseif PositionMethod == "In Air" then
                            Position = Desync.Real.CFrame.Position + Vector3.new(0, ((Head and (RootPart.Size.Y + (Head.Size.Y * 3)) or 5) + 5), 0)
                        elseif PositionMethod == "Floor Shift" then
                            Position = Desync.Real.CFrame.Position + Vector3.new(0, -((Head and (RootPart.Size.Y + (Head.Size.Y * 3)) or 5) * Math:Shift(Smoothened)), 0)
                        elseif PositionMethod == "Air Shift" then
                            Position = Desync.Real.CFrame.Position + Vector3.new(0, (((Head and (RootPart.Size.Y + (Head.Size.Y * 3)) or 5) * 2) * Math:Shift(Smoothened)), 0)
                        elseif PositionMethod == "Last Position" then
                            Position = Atlanta.Locals.LastPosition.Position
                        elseif PositionMethod == "Random" then
                            local Smoothened2 = Math:Shift(Smoothened)
                            --
                            Position = Desync.Real.CFrame.Position + Vector3.new(Random(-10, 10) , Random(-10, 10), Random(-10, 10))
                        else
                            Position = Desync.Real.CFrame.Position
                        end
                        --
                        if TurnMethod == "Rotate" then
                            Turn = CFrame.Angles(Length + Rad((Smoothened * Desync.Rotate.X) + Desync.Rotate2.X), Height + Rad((Smoothened * Desync.Rotate.Y) + Desync.Rotate2.Y), Width + Rad((Smoothened * Desync.Rotate.Z) + Desync.Rotate2.Z))
                        elseif TurnMethod == "Backwards Shift" then
                            Turn = CFrame.Angles(Length, Height - Rad(Math:Shift(Smoothened) * 180), Width)
                        elseif TurnMethod == "Backwards" then
                            Turn = CFrame.Angles(Length, Height - Rad(180), Width)
                        elseif TurnMethod == "Upside Down" then
                            Position = Position - Vector3.new(0, Head and Head.Size.Y or 1, 0)
                            Turn = CFrame.Angles(Length, Height, Rad(180))
                        elseif TurnMethod == "Laying" then
                            Position = Position + Vector3.new(0, -(RootPart.Size.Y + ((Head and Head.Size.Y or 1) * 0.5)), 0)
                            Turn = CFrame.Angles(Rad(90), 0, -Height)
                        elseif TurnMethod == "Random" then
                            Turn = CFrame.Angles(Length + Rad(Random(-360, 360)), Height + Rad(Random(-360, 360)), Width + Rad(Random(-360, 360)))
                        elseif TurnMethod == "Jitter" then
                            Turn = CFrame.Angles(Length + Rad(Random(-3, 3)), Height + Rad(Random(-3, 3)), Width + Rad(Random(-3, 3)))
                        else
                            Turn = CFrame.Angles(Length, Height, Width)
                        end
                        --
                        Desync.Fake.CFrame = CFrame.new(Position) * Turn
                        --
                        if VelocityMethod == "StandBug" then
                            Desync.Fake.Velocity = Vector3.new(9999999999999, -9999999999999, 9999999999999)
                            Desync.Fake.RotVelocity = Vector3.new(9999999999999, -9999999999999, 9999999999999)
                        elseif VelocityMethod == "Destroy Stand" then
                        Desync.Fake.CFrame = CFrame.new(-9999999999999999999999999999999999999999999999999999999, -9999999999999999999999999999999999999999999999999999999, -9999999999999999999999999999999999999999999999999999999) * CFrame.Angles(-9999999999999999999999999999999999999999999999999999999, -9999999999999999999999999999999999999999999999999999999, -9999999999999999999999999999999999999999999999999999999)
                        elseif VelocityMethod == "Furthest It Can Go" then
                           Desync.Fake.Velocity = Vector3.new(-999999999999999999999999999999, -999999999999999999999999999999, -999999999999999999999999999999)
                           Desync.Fake.RotVelocity = Vector3.new(-999999999999999999999999999999, -999999999999999999999999999999, -999999999999999999999999999999)
                            Desync.Fake.CFrame = CFrame.new(-999999999999999999999999999999, -999999999999999999999999999999, 999999999999999999999999999999) * CFrame.Angles(-999999999999999999999999999999, -999999999999999999999999999999, 999999999999999999999999999999)
                        elseif VelocityMethod == "Reversed" then
                            Desync.Fake.Velocity = -Desync.Real.Velocity
                            Desync.Fake.RotVelocity = -Desync.Real.RotVelocity
                        elseif VelocityMethod == "Up" then
                            Desync.Fake.Velocity = Vector3.new(0, 3000, 0)
                            Desync.Fake.RotVelocity = Vector3.new(0, 3000, 0)
                        elseif VelocityMethod == "Down" then
                            Desync.Fake.Velocity = Vector3.new(0, -3000, 0)
                            Desync.Fake.RotVelocity = Vector3.new(0, -3000, 0)
                        elseif VelocityMethod == "Left" then
                            Desync.Fake.Velocity = Vector3.new(3000, 0, 0)
                            Desync.Fake.RotVelocity = Vector3.new(3000, 0, 0)
                        elseif VelocityMethod == "Right" then
                            Desync.Fake.Velocity = Vector3.new(0, 0, 3000)
                            Desync.Fake.RotVelocity = Vector3.new(0, 0, 3000)
                        else
                            Desync.Fake.Velocity = Desync.Real.Velocity
                            Desync.Fake.RotVelocity = Desync.Real.RotVelocity
                        end
                        --
                        if VelocityMethod ~= "StandBug" and VelocityMethod ~= "Off" then
                            Desync.Fake.Velocity = Desync.Fake.Velocity * VelocityMultiplier
                            Desync.Fake.RotVelocity = Desync.Fake.RotVelocity * VelocityMultiplier
                        end
                    end 
                end
                --
                if Flags["MiscExtra_LagSwitch"]:Get() then
                    Network.IncomingReplicationLag = Flags["MiscExtra_LagSwitchAmmount"]:Get()
                else
                    Network.IncomingReplicationLag = 0
                end
            end)
            --
            Utility:Connection(RunService.RenderStepped, function()
                for Index, Value in pairs(Visuals.Bases) do
                    Utility:ThreadFunction(function()
                        Value:Update()
                    end, "3x02")
                end
                --

                --
                Utility:ThreadFunction(Library.UpdateHue, "0x01")
                Utility:ThreadFunction(Visuals.Update, "3x01")
                Utility:ThreadFunction(Movement.Update, "4x01")
                Utility:ThreadFunction(Chat.AttemptSend, "5x01")
            end)
            --
            Utility:Connection(RunService.Heartbeat, function()
                local Tick = tick()
                local FakeLagging = false
                --
                local Object, Humanoid, RootPart = Atlanta:ValidateClient(Client)
                --
                if RootPart then
                    Desync.Real.CFrame = RootPart.CFrame
                    Desync.Real.Velocity = RootPart.Velocity
                    Desync.Real.RotVelocity = RootPart.RotVelocity
                    --
                    local Normal = false
                    --
                    if Flags["MiscExtra_FakeLagKey"]:Active() then
                        local FakeLagMultiplier = Flags["MiscExtra_FakeLagMultiplier"]:Get()
                        local FakeLagAmmount = (Flags["MiscExtra_FakeLagAmmount"]:Get() / 7500) * FakeLagMultiplier
                        --
                        if (Tick - Atlanta.Locals.LastTick) < FakeLagAmmount then
                            sethiddenproperty(RootPart, "NetworkIsSleeping", false)
                            --
                            if Desync.Enabled then
                                RootPart.CFrame = Desync.Fake.CFrame or RootPart.CFrame
                                RootPart.Velocity = Desync.Fake.Velocity or RootPart.Velocity
                                RootPart.RotVelocity = Desync.Fake.RotVelocity or RootPart.RotVelocity
                            end
                            --
                            sethiddenproperty(RootPart, "NetworkIsSleeping", true)
                            --
                            FakeLagging = true
                        else
                            Atlanta.Locals.LastTick = Tick
                            --
                            sethiddenproperty(RootPart, "NetworkIsSleeping", false)
                            --
                            if Flags["MiscExtra_Return"]:Get() then
                                if Flags["MiscExtra_ReturnType"]:Get() == "Always" then
                                    Normal = true
                                else
                                    Normal = Random(1, 2) == 1
                                end
                            end
                        end
                    end
                    --
                    if Flags["MiscExtra_DisableNetworkingKey"]:Active() then
                        sethiddenproperty(RootPart, "NetworkIsSleeping", true)
                    end
                    --
                    if Desync.Enabled then
                        RootPart.CFrame = Normal and Desync.Real.CFrame or (Desync.Fake.CFrame or RootPart.CFrame)
                        RootPart.Velocity = Desync.Fake.Velocity or RootPart.Velocity
                        RootPart.RotVelocity = Desync.Fake.RotVelocity or RootPart.RotVelocity
                        --
                        Desync.Sent = RootPart.CFrame
                    end
                end
                --
                if (Tick - Atlanta.Locals.LastPreviewUpdate) > 0.05 then
                    Utility:ThreadFunction(Utility.UpdatePreview)
                    Atlanta.Locals.LastPreviewUpdate = Tick
                end
                --
                Utility:ThreadFunction(Visualisation.Update, "6x01", FakeLagging)
            end)
            --
            Utility:Connection(Players.PlayerAdded, function(Player)
                Atlanta:PlayerAdded(Player)
            end)
            --
            Utility:Connection(Client.CharacterAdded, function(Character)
                repeat Wait() until Character:FindFirstChildOfClass("Humanoid")
                local Humanoid = Character:FindFirstChildOfClass("Humanoid")
                --
                Movement:HandleHumanoid(Humanoid, "4x02")
                --
                Wait(0.5)
                --
                --Visualisation:CreateClone(Character)
            end)
            --
            Utility:Connection(Client.CharacterRemoving, function(Character)
                if Visualisation.Character then
                    for Index, Value in pairs(Visualisation.Character) do
                        Utility:RemoveInstance(Value)
                    end
                end
                --
                Visualisation.Character = nil
            end)
            --
        end
        --
        if Object then
        end
    end
    --
    Window:Initialize()
--[[   Utility:UpdatePreview(true)]]
    Config:Show()
    --
    --Library:SaveConfig()
end
end
loadstring(game:HttpGet("https://raw.githubusercontent.com/bebepro/pastesense/refs/heads/main/pastesense"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/flanchhh/AntiV2/refs/heads/main/Anti%20v2.lua"))();
